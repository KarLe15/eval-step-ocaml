[
  {
    "current_expression": {
      "expr": "((merge_sort [9; 8; 7; 6])[@env0 ])",
      "envs": {
        "env0": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env1 ])",
              "envs": {
                "env1": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr": "((merge_sort)[@env0 ]) [9; 8; 7; 6]",
      "envs": {
        "env0": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env1 ])",
              "envs": {
                "env1": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "SubstFun" ]
  },
  {
    "current_expression": {
      "expr":
        "((fun l ->\n    ((match l with\n      | [] -> []\n      | _::[] -> l\n      | _ ->\n          let (a, b) = split l in\n          let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n    [@env0 ]))[@env1 ]) [9; 8; 7; 6]",
      "envs": {
        "env0": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env2 ])",
              "envs": {
                "env2": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "(fun l ->\n   ((match l with\n     | [] -> []\n     | _::[] -> l\n     | _ ->\n         let (a, b) = split l in\n         let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n   [@env1 ][@env0 ])) [9; 8; 7; 6]",
      "envs": {
        "env0": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env2 ])",
              "envs": {
                "env2": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "SubstCombine" ]
  },
  {
    "current_expression": {
      "expr":
        "(fun l ->\n   ((match l with\n     | [] -> []\n     | _::[] -> l\n     | _ ->\n         let (a, b) = split l in\n         let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n   [@env0 ])) [9; 8; 7; 6]",
      "envs": {
        "env0": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env1 ])",
              "envs": {
                "env1": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "(fun l ->\n   match l with\n   | [] -> []\n   | _::[] -> l\n   | _ ->\n       ((let (a, b) = split l in\n         let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n       [@env0 ])) [9; 8; 7; 6]",
      "envs": {
        "env0": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env1 ])",
              "envs": {
                "env1": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "ApplyFunComplete" ]
  },
  {
    "current_expression": {
      "expr":
        "((match l with\n  | [] -> []\n  | _::[] -> l\n  | _ ->\n      ((let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n      [@env0 ]))\n[@env1 ])",
      "envs": {
        "env0": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env2 ])",
              "envs": {
                "env2": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "l": {
            "corec": [],
            "expr": { "expr": "[9; 8; 7; 6]", "envs": {} }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "match ((l)[@env3 ]) with\n| [] -> []\n| _::[] -> ((l)[@env0 ])\n| _ ->\n    ((let (a, b) = split l in\n      let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n    [@env2 ][@env1 ])",
      "envs": {
        "env0": {
          "l": {
            "corec": [],
            "expr": { "expr": "[9; 8; 7; 6]", "envs": {} }
          }
        },
        "env1": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "l": {
            "corec": [],
            "expr": { "expr": "[9; 8; 7; 6]", "envs": {} }
          }
        },
        "env3": {
          "l": {
            "corec": [],
            "expr": { "expr": "[9; 8; 7; 6]", "envs": {} }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "match [9; 8; 7; 6] with\n| [] -> []\n| _::[] -> ((l)[@env0 ])\n| _ ->\n    ((let (a, b) = split l in\n      let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n    [@env2 ][@env1 ])",
      "envs": {
        "env0": {
          "l": {
            "corec": [],
            "expr": { "expr": "[9; 8; 7; 6]", "envs": {} }
          }
        },
        "env1": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "l": {
            "corec": [],
            "expr": { "expr": "[9; 8; 7; 6]", "envs": {} }
          }
        }
      }
    },
    "step": [ "Match" ]
  },
  {
    "current_expression": {
      "expr":
        "((let (a, b) = split l in\n  let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n[@env1 ][@env0 ])",
      "envs": {
        "env0": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env2 ])",
              "envs": {
                "env2": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "l": {
            "corec": [],
            "expr": { "expr": "[9; 8; 7; 6]", "envs": {} }
          }
        }
      }
    },
    "step": [ "SubstCombine" ]
  },
  {
    "current_expression": {
      "expr":
        "((let (a, b) = split l in\n  let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n[@env0 ])",
      "envs": {
        "env0": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env1 ])",
              "envs": {
                "env1": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l": {
            "corec": [],
            "expr": { "expr": "[9; 8; 7; 6]", "envs": {} }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) = ((split l)[@env1 ]) in\n((let aa = merge_sort a in let bb = merge_sort b in merge aa bb)[@env0 ])",
      "envs": {
        "env0": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env2 ])",
              "envs": {
                "env2": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "l": {
            "corec": [],
            "expr": { "expr": "[9; 8; 7; 6]", "envs": {} }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) = ((split l)[@env2 ]) in\nlet aa = ((merge_sort a)[@env1 ]) in ((let bb = merge_sort b in merge aa bb)\n  [@env0 ])",
      "envs": {
        "env0": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "l": {
            "corec": [],
            "expr": { "expr": "[9; 8; 7; 6]", "envs": {} }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) = ((split l)[@env3 ]) in\nlet aa = ((merge_sort a)[@env2 ]) in\nlet bb = ((merge_sort b)[@env1 ]) in ((merge aa bb)[@env0 ])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "l": {
            "corec": [],
            "expr": { "expr": "[9; 8; 7; 6]", "envs": {} }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) = ((split l)[@env3 ]) in\nlet aa = ((merge_sort a)[@env2 ]) in\nlet bb = ((merge_sort b)[@env1 ]) in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "l": {
            "corec": [],
            "expr": { "expr": "[9; 8; 7; 6]", "envs": {} }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) = ((split l)[@env3 ]) in\nlet aa = ((merge_sort a)[@env2 ]) in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "l": {
            "corec": [],
            "expr": { "expr": "[9; 8; 7; 6]", "envs": {} }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) = ((split l)[@env3 ]) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "l": {
            "corec": [],
            "expr": { "expr": "[9; 8; 7; 6]", "envs": {} }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) = ((split)[@env4 ]) ((l)[@env3 ]) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "l": {
            "corec": [],
            "expr": { "expr": "[9; 8; 7; 6]", "envs": {} }
          }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) = ((split)[@env3 ]) [9; 8; 7; 6] in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstFun" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  ((fun l ->\n      match l with\n      | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n      | p::[] -> ([p], [])\n      | [] -> ([], []))[@env3 ]) [9; 8; 7; 6] in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  (fun l ->\n     ((match l with\n       | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n       | p::[] -> ([p], [])\n       | [] -> ([], []))\n     [@env3 ])) [9; 8; 7; 6] in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  (fun l ->\n     match l with\n     | p::q::r -> ((let (a, b) = split r in ((p :: a), (q :: b)))[@env3 ])\n     | p::[] -> ([p], [])\n     | [] -> ([], [])) [9; 8; 7; 6] in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "ApplyFunComplete" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  ((match l with\n    | p::q::r -> ((let (a, b) = split r in ((p :: a), (q :: b)))[@env3 ])\n    | p::[] -> ([p], [])\n    | [] -> ([], []))\n  [@env4 ]) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        },
        "env4": {
          "l": {
            "corec": [],
            "expr": { "expr": "[9; 8; 7; 6]", "envs": {} }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  match ((l)[@env4 ]) with\n  | p::q::r -> ((let (a, b) = split r in ((p :: a), (q :: b)))[@env3 ])\n  | p::[] -> ([p], [])\n  | [] -> ([], []) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        },
        "env4": {
          "l": {
            "corec": [],
            "expr": { "expr": "[9; 8; 7; 6]", "envs": {} }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  match [9; 8; 7; 6] with\n  | p::q::r -> ((let (a, b) = split r in ((p :: a), (q :: b)))[@env3 ])\n  | p::[] -> ([p], [])\n  | [] -> ([], []) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "Match" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) = ((let (a, b) = split r in ((p :: a), (q :: b)))[@env4 ][@env3 ]) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        },
        "env4": {
          "r": { "corec": [], "expr": { "expr": "[7; 6]", "envs": {} } },
          "q": { "corec": [], "expr": { "expr": "8", "envs": {} } },
          "p": { "corec": [], "expr": { "expr": "9", "envs": {} } }
        }
      }
    },
    "step": [ "SubstCombine" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) = ((let (a, b) = split r in ((p :: a), (q :: b)))[@env3 ]) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "r": { "corec": [], "expr": { "expr": "[7; 6]", "envs": {} } },
          "q": { "corec": [], "expr": { "expr": "8", "envs": {} } },
          "p": { "corec": [], "expr": { "expr": "9", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) = ((split r)[@env4 ]) in ((((p :: a), (q :: b)))[@env3 ]) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "q": { "corec": [], "expr": { "expr": "8", "envs": {} } },
          "p": { "corec": [], "expr": { "expr": "9", "envs": {} } }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "r": { "corec": [], "expr": { "expr": "[7; 6]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) = ((split r)[@env5 ]) in\n  (((p :: a)[@env3 ]), ((q :: b)[@env4 ])) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": { "p": { "corec": [], "expr": { "expr": "9", "envs": {} } } },
        "env4": { "q": { "corec": [], "expr": { "expr": "8", "envs": {} } } },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "r": { "corec": [], "expr": { "expr": "[7; 6]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) = ((split r)[@env5 ]) in\n  (((p :: a)[@env3 ]), ((q :: b)[@env4 ])) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": { "p": { "corec": [], "expr": { "expr": "9", "envs": {} } } },
        "env4": { "q": { "corec": [], "expr": { "expr": "8", "envs": {} } } },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "r": { "corec": [], "expr": { "expr": "[7; 6]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) = ((split r)[@env5 ]) in\n  ((((p)[@env3 ]) :: a), ((q :: b)[@env4 ])) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": { "p": { "corec": [], "expr": { "expr": "9", "envs": {} } } },
        "env4": { "q": { "corec": [], "expr": { "expr": "8", "envs": {} } } },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "r": { "corec": [], "expr": { "expr": "[7; 6]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) = ((split r)[@env5 ]) in\n  ((((p)[@env3 ]) :: a), ((q :: b)[@env4 ])) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": { "p": { "corec": [], "expr": { "expr": "9", "envs": {} } } },
        "env4": { "q": { "corec": [], "expr": { "expr": "8", "envs": {} } } },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "r": { "corec": [], "expr": { "expr": "[7; 6]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) = ((split r)[@env5 ]) in\n  ((((p)[@env3 ]) :: a), (((q)[@env4 ]) :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": { "p": { "corec": [], "expr": { "expr": "9", "envs": {} } } },
        "env4": { "q": { "corec": [], "expr": { "expr": "8", "envs": {} } } },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "r": { "corec": [], "expr": { "expr": "[7; 6]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) = ((split)[@env6 ]) ((r)[@env5 ]) in\n  ((((p)[@env3 ]) :: a), (((q)[@env4 ]) :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": { "p": { "corec": [], "expr": { "expr": "9", "envs": {} } } },
        "env4": { "q": { "corec": [], "expr": { "expr": "8", "envs": {} } } },
        "env5": {
          "r": { "corec": [], "expr": { "expr": "[7; 6]", "envs": {} } }
        },
        "env6": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) = ((split)[@env5 ]) ((r)[@env4 ]) in\n  ((9 :: a), (((q)[@env3 ]) :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": { "q": { "corec": [], "expr": { "expr": "8", "envs": {} } } },
        "env4": {
          "r": { "corec": [], "expr": { "expr": "[7; 6]", "envs": {} } }
        },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) = ((split)[@env4 ]) ((r)[@env3 ]) in ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "r": { "corec": [], "expr": { "expr": "[7; 6]", "envs": {} } }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) = let (a, b) = ((split)[@env3 ]) [7; 6] in ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstFun" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) =\n    ((fun l ->\n        match l with\n        | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n        | p::[] -> ([p], [])\n        | [] -> ([], []))[@env3 ]) [7; 6] in\n  ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) =\n    (fun l ->\n       ((match l with\n         | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n         | p::[] -> ([p], [])\n         | [] -> ([], []))\n       [@env3 ])) [7; 6] in\n  ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) =\n    (fun l ->\n       match l with\n       | p::q::r -> ((let (a, b) = split r in ((p :: a), (q :: b)))[@env3 ])\n       | p::[] -> ([p], [])\n       | [] -> ([], [])) [7; 6] in\n  ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "ApplyFunComplete" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) =\n    ((match l with\n      | p::q::r -> ((let (a, b) = split r in ((p :: a), (q :: b)))[@env3 ])\n      | p::[] -> ([p], [])\n      | [] -> ([], []))\n    [@env4 ]) in\n  ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        },
        "env4": {
          "l": { "corec": [], "expr": { "expr": "[7; 6]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) =\n    match ((l)[@env4 ]) with\n    | p::q::r -> ((let (a, b) = split r in ((p :: a), (q :: b)))[@env3 ])\n    | p::[] -> ([p], [])\n    | [] -> ([], []) in\n  ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        },
        "env4": {
          "l": { "corec": [], "expr": { "expr": "[7; 6]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) =\n    match [7; 6] with\n    | p::q::r -> ((let (a, b) = split r in ((p :: a), (q :: b)))[@env3 ])\n    | p::[] -> ([p], [])\n    | [] -> ([], []) in\n  ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "Match" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) = ((let (a, b) = split r in ((p :: a), (q :: b)))\n    [@env4 ][@env3 ]) in\n  ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        },
        "env4": {
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "q": { "corec": [], "expr": { "expr": "6", "envs": {} } },
          "p": { "corec": [], "expr": { "expr": "7", "envs": {} } }
        }
      }
    },
    "step": [ "SubstCombine" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) = ((let (a, b) = split r in ((p :: a), (q :: b)))[@env3 ]) in\n  ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "q": { "corec": [], "expr": { "expr": "6", "envs": {} } },
          "p": { "corec": [], "expr": { "expr": "7", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) =\n    let (a, b) = ((split r)[@env4 ]) in ((((p :: a), (q :: b)))[@env3 ]) in\n  ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "q": { "corec": [], "expr": { "expr": "6", "envs": {} } },
          "p": { "corec": [], "expr": { "expr": "7", "envs": {} } }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) =\n    let (a, b) = ((split r)[@env5 ]) in\n    (((p :: a)[@env3 ]), ((q :: b)[@env4 ])) in\n  ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": { "p": { "corec": [], "expr": { "expr": "7", "envs": {} } } },
        "env4": { "q": { "corec": [], "expr": { "expr": "6", "envs": {} } } },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) =\n    let (a, b) = ((split r)[@env5 ]) in\n    (((p :: a)[@env3 ]), ((q :: b)[@env4 ])) in\n  ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": { "p": { "corec": [], "expr": { "expr": "7", "envs": {} } } },
        "env4": { "q": { "corec": [], "expr": { "expr": "6", "envs": {} } } },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) =\n    let (a, b) = ((split r)[@env5 ]) in\n    ((((p)[@env3 ]) :: a), ((q :: b)[@env4 ])) in\n  ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": { "p": { "corec": [], "expr": { "expr": "7", "envs": {} } } },
        "env4": { "q": { "corec": [], "expr": { "expr": "6", "envs": {} } } },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) =\n    let (a, b) = ((split r)[@env5 ]) in\n    ((((p)[@env3 ]) :: a), ((q :: b)[@env4 ])) in\n  ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": { "p": { "corec": [], "expr": { "expr": "7", "envs": {} } } },
        "env4": { "q": { "corec": [], "expr": { "expr": "6", "envs": {} } } },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) =\n    let (a, b) = ((split r)[@env5 ]) in\n    ((((p)[@env3 ]) :: a), (((q)[@env4 ]) :: b)) in\n  ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": { "p": { "corec": [], "expr": { "expr": "7", "envs": {} } } },
        "env4": { "q": { "corec": [], "expr": { "expr": "6", "envs": {} } } },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) =\n    let (a, b) = ((split)[@env6 ]) ((r)[@env5 ]) in\n    ((((p)[@env3 ]) :: a), (((q)[@env4 ]) :: b)) in\n  ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": { "p": { "corec": [], "expr": { "expr": "7", "envs": {} } } },
        "env4": { "q": { "corec": [], "expr": { "expr": "6", "envs": {} } } },
        "env5": {
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env6": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) =\n    let (a, b) = ((split)[@env5 ]) ((r)[@env4 ]) in\n    ((7 :: a), (((q)[@env3 ]) :: b)) in\n  ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": { "q": { "corec": [], "expr": { "expr": "6", "envs": {} } } },
        "env4": {
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) =\n    let (a, b) = ((split)[@env4 ]) ((r)[@env3 ]) in ((7 :: a), (6 :: b)) in\n  ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) = let (a, b) = ((split)[@env3 ]) [] in ((7 :: a), (6 :: b)) in\n  ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstFun" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) =\n    let (a, b) =\n      ((fun l ->\n          match l with\n          | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n          | p::[] -> ([p], [])\n          | [] -> ([], []))[@env3 ]) [] in\n    ((7 :: a), (6 :: b)) in\n  ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) =\n    let (a, b) =\n      (fun l ->\n         ((match l with\n           | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n           | p::[] -> ([p], [])\n           | [] -> ([], []))\n         [@env3 ])) [] in\n    ((7 :: a), (6 :: b)) in\n  ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) =\n    let (a, b) =\n      (fun l ->\n         match l with\n         | p::q::r -> ((let (a, b) = split r in ((p :: a), (q :: b)))\n             [@env3 ])\n         | p::[] -> ([p], [])\n         | [] -> ([], [])) [] in\n    ((7 :: a), (6 :: b)) in\n  ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "ApplyFunComplete" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) =\n    let (a, b) =\n      ((match l with\n        | p::q::r -> ((let (a, b) = split r in ((p :: a), (q :: b)))[@env3 ])\n        | p::[] -> ([p], [])\n        | [] -> ([], []))\n      [@env4 ]) in\n    ((7 :: a), (6 :: b)) in\n  ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        },
        "env4": {
          "l": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) =\n    let (a, b) =\n      match ((l)[@env4 ]) with\n      | p::q::r -> ((let (a, b) = split r in ((p :: a), (q :: b)))[@env3 ])\n      | p::[] -> ([p], [])\n      | [] -> ([], []) in\n    ((7 :: a), (6 :: b)) in\n  ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        },
        "env4": {
          "l": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) =\n    let (a, b) =\n      match [] with\n      | p::q::r -> ((let (a, b) = split r in ((p :: a), (q :: b)))[@env3 ])\n      | p::[] -> ([p], [])\n      | [] -> ([], []) in\n    ((7 :: a), (6 :: b)) in\n  ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "Match" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) = let (a, b) = ([], []) in ((7 :: a), (6 :: b)) in\n  ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "Let" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) = ((((7 :: a), (6 :: b)))[@env3 ]) in ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "b": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "a": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) = (((7 :: a)[@env3 ]), ((6 :: b)[@env4 ])) in\n  ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "a": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env4": {
          "b": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) = (((7 :: a)[@env3 ]), ((6 :: b)[@env4 ])) in\n  ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "a": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env4": {
          "b": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) = ((7 :: ((a)[@env3 ])), ((6 :: b)[@env4 ])) in\n  ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "a": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env4": {
          "b": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) = ((7 :: ((a)[@env3 ])), ((6 :: b)[@env4 ])) in\n  ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "a": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env4": {
          "b": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) =\n  let (a, b) = ((7 :: ((a)[@env3 ])), (6 :: ((b)[@env4 ]))) in\n  ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "a": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env4": {
          "b": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) = let (a, b) = ([7], (6 :: ((b)[@env3 ]))) in ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "b": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) = let (a, b) = ([7], [6]) in ((9 :: a), (8 :: b)) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "Let" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) = ((((9 :: a), (8 :: b)))[@env3 ]) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "b": { "corec": [], "expr": { "expr": "[6]", "envs": {} } },
          "a": { "corec": [], "expr": { "expr": "[7]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) = (((9 :: a)[@env3 ]), ((8 :: b)[@env4 ])) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "a": { "corec": [], "expr": { "expr": "[7]", "envs": {} } }
        },
        "env4": {
          "b": { "corec": [], "expr": { "expr": "[6]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) = (((9 :: a)[@env3 ]), ((8 :: b)[@env4 ])) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "a": { "corec": [], "expr": { "expr": "[7]", "envs": {} } }
        },
        "env4": {
          "b": { "corec": [], "expr": { "expr": "[6]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) = ((9 :: ((a)[@env3 ])), ((8 :: b)[@env4 ])) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "a": { "corec": [], "expr": { "expr": "[7]", "envs": {} } }
        },
        "env4": {
          "b": { "corec": [], "expr": { "expr": "[6]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) = ((9 :: ((a)[@env3 ])), ((8 :: b)[@env4 ])) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "a": { "corec": [], "expr": { "expr": "[7]", "envs": {} } }
        },
        "env4": {
          "b": { "corec": [], "expr": { "expr": "[6]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) = ((9 :: ((a)[@env3 ])), (8 :: ((b)[@env4 ]))) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "a": { "corec": [], "expr": { "expr": "[7]", "envs": {} } }
        },
        "env4": {
          "b": { "corec": [], "expr": { "expr": "[6]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) = ([9; 7], (8 :: ((b)[@env3 ]))) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "b": { "corec": [], "expr": { "expr": "[6]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let (a, b) = ([9; 7], [8; 6]) in\nlet aa = ((merge_sort)[@env2 ]) a in\nlet bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "Let" ]
  },
  {
    "current_expression": {
      "expr":
        "((let aa = ((merge_sort)[@env2 ]) a in\n  let bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb)\n[@env3 ])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "b": { "corec": [], "expr": { "expr": "[8; 6]", "envs": {} } },
          "a": { "corec": [], "expr": { "expr": "[9; 7]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = ((((merge_sort)[@env3 ]) a)[@env4 ]) in\n((let bb = ((merge_sort)[@env1 ]) b in ((merge)[@env0 ]) aa bb)[@env2 ])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "b": { "corec": [], "expr": { "expr": "[8; 6]", "envs": {} } }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "a": { "corec": [], "expr": { "expr": "[9; 7]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = ((((merge_sort)[@env3 ]) a)[@env4 ]) in\nlet bb = ((((merge_sort)[@env1 ]) b)[@env2 ]) in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "b": { "corec": [], "expr": { "expr": "[8; 6]", "envs": {} } }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "a": { "corec": [], "expr": { "expr": "[9; 7]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = ((((merge_sort)[@env3 ]) a)[@env4 ]) in\nlet bb = ((merge_sort)[@env2 ]) ((b)[@env1 ]) in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "b": { "corec": [], "expr": { "expr": "[8; 6]", "envs": {} } }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "a": { "corec": [], "expr": { "expr": "[9; 7]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = ((merge_sort)[@env4 ]) ((a)[@env3 ]) in\nlet bb = ((merge_sort)[@env2 ]) ((b)[@env1 ]) in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "b": { "corec": [], "expr": { "expr": "[8; 6]", "envs": {} } }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "a": { "corec": [], "expr": { "expr": "[9; 7]", "envs": {} } }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = ((merge_sort)[@env3 ]) ((a)[@env2 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "a": { "corec": [], "expr": { "expr": "[9; 7]", "envs": {} } }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = ((merge_sort)[@env2 ]) [9; 7] in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "SubstFun" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  ((fun l ->\n      ((match l with\n        | [] -> []\n        | _::[] -> l\n        | _ ->\n            let (a, b) = split l in\n            let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n      [@env2 ]))[@env3 ]) [9; 7] in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  (fun l ->\n     ((match l with\n       | [] -> []\n       | _::[] -> l\n       | _ ->\n           let (a, b) = split l in\n           let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n     [@env3 ][@env2 ])) [9; 7] in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "SubstCombine" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  (fun l ->\n     ((match l with\n       | [] -> []\n       | _::[] -> l\n       | _ ->\n           let (a, b) = split l in\n           let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n     [@env2 ])) [9; 7] in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  (fun l ->\n     match l with\n     | [] -> []\n     | _::[] -> l\n     | _ ->\n         ((let (a, b) = split l in\n           let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n         [@env2 ])) [9; 7] in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "ApplyFunComplete" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        ((let (a, b) = split l in\n          let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n        [@env2 ]))\n  [@env3 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "l": { "corec": [], "expr": { "expr": "[9; 7]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  match ((l)[@env5 ]) with\n  | [] -> []\n  | _::[] -> ((l)[@env2 ])\n  | _ ->\n      ((let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n      [@env4 ][@env3 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "l": { "corec": [], "expr": { "expr": "[9; 7]", "envs": {} } }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env4": {
          "l": { "corec": [], "expr": { "expr": "[9; 7]", "envs": {} } }
        },
        "env5": {
          "l": { "corec": [], "expr": { "expr": "[9; 7]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  match [9; 7] with\n  | [] -> []\n  | _::[] -> ((l)[@env2 ])\n  | _ ->\n      ((let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n      [@env4 ][@env3 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "l": { "corec": [], "expr": { "expr": "[9; 7]", "envs": {} } }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env4": {
          "l": { "corec": [], "expr": { "expr": "[9; 7]", "envs": {} } }
        }
      }
    },
    "step": [ "Match" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  ((let (a, b) = split l in\n    let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ][@env2 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "l": { "corec": [], "expr": { "expr": "[9; 7]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstCombine" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  ((let (a, b) = split l in\n    let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env2 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l": { "corec": [], "expr": { "expr": "[9; 7]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) = ((split l)[@env3 ]) in\n  ((let aa = merge_sort a in let bb = merge_sort b in merge aa bb)[@env2 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "l": { "corec": [], "expr": { "expr": "[9; 7]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) = ((split l)[@env4 ]) in\n  let aa = ((merge_sort a)[@env3 ]) in\n  ((let bb = merge_sort b in merge aa bb)[@env2 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "l": { "corec": [], "expr": { "expr": "[9; 7]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) = ((split l)[@env5 ]) in\n  let aa = ((merge_sort a)[@env4 ]) in\n  let bb = ((merge_sort b)[@env3 ]) in ((merge aa bb)[@env2 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "l": { "corec": [], "expr": { "expr": "[9; 7]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) = ((split l)[@env5 ]) in\n  let aa = ((merge_sort a)[@env4 ]) in\n  let bb = ((merge_sort b)[@env3 ]) in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "l": { "corec": [], "expr": { "expr": "[9; 7]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) = ((split l)[@env5 ]) in\n  let aa = ((merge_sort a)[@env4 ]) in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "l": { "corec": [], "expr": { "expr": "[9; 7]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) = ((split l)[@env5 ]) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "l": { "corec": [], "expr": { "expr": "[9; 7]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) = ((split)[@env6 ]) ((l)[@env5 ]) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env9 ])",
              "envs": {
                "env9": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "l": { "corec": [], "expr": { "expr": "[9; 7]", "envs": {} } }
        },
        "env6": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) = ((split)[@env5 ]) [9; 7] in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstFun" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) =\n    ((fun l ->\n        match l with\n        | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n        | p::[] -> ([p], [])\n        | [] -> ([], []))[@env5 ]) [9; 7] in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) =\n    (fun l ->\n       ((match l with\n         | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n         | p::[] -> ([p], [])\n         | [] -> ([], []))\n       [@env5 ])) [9; 7] in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) =\n    (fun l ->\n       match l with\n       | p::q::r -> ((let (a, b) = split r in ((p :: a), (q :: b)))[@env5 ])\n       | p::[] -> ([p], [])\n       | [] -> ([], [])) [9; 7] in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "ApplyFunComplete" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) =\n    ((match l with\n      | p::q::r -> ((let (a, b) = split r in ((p :: a), (q :: b)))[@env5 ])\n      | p::[] -> ([p], [])\n      | [] -> ([], []))\n    [@env6 ]) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env9 ])",
              "envs": {
                "env9": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        },
        "env6": {
          "l": { "corec": [], "expr": { "expr": "[9; 7]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) =\n    match ((l)[@env6 ]) with\n    | p::q::r -> ((let (a, b) = split r in ((p :: a), (q :: b)))[@env5 ])\n    | p::[] -> ([p], [])\n    | [] -> ([], []) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env9 ])",
              "envs": {
                "env9": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        },
        "env6": {
          "l": { "corec": [], "expr": { "expr": "[9; 7]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) =\n    match [9; 7] with\n    | p::q::r -> ((let (a, b) = split r in ((p :: a), (q :: b)))[@env5 ])\n    | p::[] -> ([p], [])\n    | [] -> ([], []) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "Match" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) = ((let (a, b) = split r in ((p :: a), (q :: b)))\n    [@env6 ][@env5 ]) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env9 ])",
              "envs": {
                "env9": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        },
        "env6": {
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "q": { "corec": [], "expr": { "expr": "7", "envs": {} } },
          "p": { "corec": [], "expr": { "expr": "9", "envs": {} } }
        }
      }
    },
    "step": [ "SubstCombine" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) = ((let (a, b) = split r in ((p :: a), (q :: b)))[@env5 ]) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "q": { "corec": [], "expr": { "expr": "7", "envs": {} } },
          "p": { "corec": [], "expr": { "expr": "9", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) =\n    let (a, b) = ((split r)[@env6 ]) in ((((p :: a), (q :: b)))[@env5 ]) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env9 ])",
              "envs": {
                "env9": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "q": { "corec": [], "expr": { "expr": "7", "envs": {} } },
          "p": { "corec": [], "expr": { "expr": "9", "envs": {} } }
        },
        "env6": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) =\n    let (a, b) = ((split r)[@env7 ]) in\n    (((p :: a)[@env5 ]), ((q :: b)[@env6 ])) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env9 ])",
              "envs": {
                "env9": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env10 ])",
              "envs": {
                "env10": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": { "p": { "corec": [], "expr": { "expr": "9", "envs": {} } } },
        "env6": { "q": { "corec": [], "expr": { "expr": "7", "envs": {} } } },
        "env7": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) =\n    let (a, b) = ((split r)[@env7 ]) in\n    (((p :: a)[@env5 ]), ((q :: b)[@env6 ])) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env9 ])",
              "envs": {
                "env9": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env10 ])",
              "envs": {
                "env10": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": { "p": { "corec": [], "expr": { "expr": "9", "envs": {} } } },
        "env6": { "q": { "corec": [], "expr": { "expr": "7", "envs": {} } } },
        "env7": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) =\n    let (a, b) = ((split r)[@env7 ]) in\n    ((((p)[@env5 ]) :: a), ((q :: b)[@env6 ])) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env9 ])",
              "envs": {
                "env9": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env10 ])",
              "envs": {
                "env10": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": { "p": { "corec": [], "expr": { "expr": "9", "envs": {} } } },
        "env6": { "q": { "corec": [], "expr": { "expr": "7", "envs": {} } } },
        "env7": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) =\n    let (a, b) = ((split r)[@env7 ]) in\n    ((((p)[@env5 ]) :: a), ((q :: b)[@env6 ])) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env9 ])",
              "envs": {
                "env9": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env10 ])",
              "envs": {
                "env10": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": { "p": { "corec": [], "expr": { "expr": "9", "envs": {} } } },
        "env6": { "q": { "corec": [], "expr": { "expr": "7", "envs": {} } } },
        "env7": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) =\n    let (a, b) = ((split r)[@env7 ]) in\n    ((((p)[@env5 ]) :: a), (((q)[@env6 ]) :: b)) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env9 ])",
              "envs": {
                "env9": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env10 ])",
              "envs": {
                "env10": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": { "p": { "corec": [], "expr": { "expr": "9", "envs": {} } } },
        "env6": { "q": { "corec": [], "expr": { "expr": "7", "envs": {} } } },
        "env7": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) =\n    let (a, b) = ((split)[@env8 ]) ((r)[@env7 ]) in\n    ((((p)[@env5 ]) :: a), (((q)[@env6 ]) :: b)) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env9 ])",
              "envs": {
                "env9": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env10 ])",
              "envs": {
                "env10": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env11 ])",
              "envs": {
                "env11": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": { "p": { "corec": [], "expr": { "expr": "9", "envs": {} } } },
        "env6": { "q": { "corec": [], "expr": { "expr": "7", "envs": {} } } },
        "env7": {
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env8": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) =\n    let (a, b) = ((split)[@env7 ]) ((r)[@env6 ]) in\n    ((9 :: a), (((q)[@env5 ]) :: b)) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env9 ])",
              "envs": {
                "env9": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env10 ])",
              "envs": {
                "env10": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": { "q": { "corec": [], "expr": { "expr": "7", "envs": {} } } },
        "env6": {
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env7": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) =\n    let (a, b) = ((split)[@env6 ]) ((r)[@env5 ]) in ((9 :: a), (7 :: b)) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env9 ])",
              "envs": {
                "env9": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env6": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) = let (a, b) = ((split)[@env5 ]) [] in ((9 :: a), (7 :: b)) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstFun" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) =\n    let (a, b) =\n      ((fun l ->\n          match l with\n          | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n          | p::[] -> ([p], [])\n          | [] -> ([], []))[@env5 ]) [] in\n    ((9 :: a), (7 :: b)) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) =\n    let (a, b) =\n      (fun l ->\n         ((match l with\n           | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n           | p::[] -> ([p], [])\n           | [] -> ([], []))\n         [@env5 ])) [] in\n    ((9 :: a), (7 :: b)) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) =\n    let (a, b) =\n      (fun l ->\n         match l with\n         | p::q::r -> ((let (a, b) = split r in ((p :: a), (q :: b)))\n             [@env5 ])\n         | p::[] -> ([p], [])\n         | [] -> ([], [])) [] in\n    ((9 :: a), (7 :: b)) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "ApplyFunComplete" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) =\n    let (a, b) =\n      ((match l with\n        | p::q::r -> ((let (a, b) = split r in ((p :: a), (q :: b)))[@env5 ])\n        | p::[] -> ([p], [])\n        | [] -> ([], []))\n      [@env6 ]) in\n    ((9 :: a), (7 :: b)) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env9 ])",
              "envs": {
                "env9": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        },
        "env6": {
          "l": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) =\n    let (a, b) =\n      match ((l)[@env6 ]) with\n      | p::q::r -> ((let (a, b) = split r in ((p :: a), (q :: b)))[@env5 ])\n      | p::[] -> ([p], [])\n      | [] -> ([], []) in\n    ((9 :: a), (7 :: b)) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env9 ])",
              "envs": {
                "env9": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        },
        "env6": {
          "l": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) =\n    let (a, b) =\n      match [] with\n      | p::q::r -> ((let (a, b) = split r in ((p :: a), (q :: b)))[@env5 ])\n      | p::[] -> ([p], [])\n      | [] -> ([], []) in\n    ((9 :: a), (7 :: b)) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "Match" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) = let (a, b) = ([], []) in ((9 :: a), (7 :: b)) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "Let" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) = ((((9 :: a), (7 :: b)))[@env5 ]) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "b": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "a": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) = (((9 :: a)[@env5 ]), ((7 :: b)[@env6 ])) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env9 ])",
              "envs": {
                "env9": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "a": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env6": {
          "b": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) = (((9 :: a)[@env5 ]), ((7 :: b)[@env6 ])) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env9 ])",
              "envs": {
                "env9": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "a": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env6": {
          "b": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) = ((9 :: ((a)[@env5 ])), ((7 :: b)[@env6 ])) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env9 ])",
              "envs": {
                "env9": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "a": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env6": {
          "b": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) = ((9 :: ((a)[@env5 ])), ((7 :: b)[@env6 ])) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env9 ])",
              "envs": {
                "env9": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "a": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env6": {
          "b": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) = ((9 :: ((a)[@env5 ])), (7 :: ((b)[@env6 ]))) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env9 ])",
              "envs": {
                "env9": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "a": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env6": {
          "b": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) = ([9], (7 :: ((b)[@env5 ]))) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "b": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let (a, b) = ([9], [7]) in\n  let aa = ((merge_sort)[@env4 ]) a in\n  let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "Let" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  ((let aa = ((merge_sort)[@env4 ]) a in\n    let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb)\n  [@env5 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "b": { "corec": [], "expr": { "expr": "[7]", "envs": {} } },
          "a": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let aa = ((((merge_sort)[@env5 ]) a)[@env6 ]) in\n  ((let bb = ((merge_sort)[@env3 ]) b in ((merge)[@env2 ]) aa bb)[@env4 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "b": { "corec": [], "expr": { "expr": "[7]", "envs": {} } }
        },
        "env5": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env9 ])",
              "envs": {
                "env9": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env6": {
          "a": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let aa = ((((merge_sort)[@env5 ]) a)[@env6 ]) in\n  let bb = ((((merge_sort)[@env3 ]) b)[@env4 ]) in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "b": { "corec": [], "expr": { "expr": "[7]", "envs": {} } }
        },
        "env5": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env9 ])",
              "envs": {
                "env9": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env6": {
          "a": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let aa = ((((merge_sort)[@env5 ]) a)[@env6 ]) in\n  let bb = ((merge_sort)[@env4 ]) ((b)[@env3 ]) in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "b": { "corec": [], "expr": { "expr": "[7]", "envs": {} } }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env9 ])",
              "envs": {
                "env9": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env6": {
          "a": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let aa = ((merge_sort)[@env6 ]) ((a)[@env5 ]) in\n  let bb = ((merge_sort)[@env4 ]) ((b)[@env3 ]) in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "b": { "corec": [], "expr": { "expr": "[7]", "envs": {} } }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "a": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env6": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env9 ])",
              "envs": {
                "env9": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let aa = ((merge_sort)[@env5 ]) ((a)[@env4 ]) in\n  let bb = ((merge_sort)[@env3 ]) [7] in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "a": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env5": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let aa = ((merge_sort)[@env4 ]) [9] in\n  let bb = ((merge_sort)[@env3 ]) [7] in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "SubstFun" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let aa =\n    ((fun l ->\n        ((match l with\n          | [] -> []\n          | _::[] -> l\n          | _ ->\n              let (a, b) = split l in\n              let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n        [@env4 ]))[@env5 ]) [9] in\n  let bb = ((merge_sort)[@env3 ]) [7] in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env5": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let aa =\n    (fun l ->\n       ((match l with\n         | [] -> []\n         | _::[] -> l\n         | _ ->\n             let (a, b) = split l in\n             let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n       [@env5 ][@env4 ])) [9] in\n  let bb = ((merge_sort)[@env3 ]) [7] in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env5": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "SubstCombine" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let aa =\n    (fun l ->\n       ((match l with\n         | [] -> []\n         | _::[] -> l\n         | _ ->\n             let (a, b) = split l in\n             let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n       [@env4 ])) [9] in\n  let bb = ((merge_sort)[@env3 ]) [7] in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let aa =\n    (fun l ->\n       match l with\n       | [] -> []\n       | _::[] -> l\n       | _ ->\n           ((let (a, b) = split l in\n             let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n           [@env4 ])) [9] in\n  let bb = ((merge_sort)[@env3 ]) [7] in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "ApplyFunComplete" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let aa =\n    ((match l with\n      | [] -> []\n      | _::[] -> l\n      | _ ->\n          ((let (a, b) = split l in\n            let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n          [@env4 ]))\n    [@env5 ]) in\n  let bb = ((merge_sort)[@env3 ]) [7] in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env5": {
          "l": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let aa =\n    match ((l)[@env7 ]) with\n    | [] -> []\n    | _::[] -> ((l)[@env4 ])\n    | _ ->\n        ((let (a, b) = split l in\n          let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n        [@env6 ][@env5 ]) in\n  let bb = ((merge_sort)[@env3 ]) [7] in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env9 ])",
              "envs": {
                "env9": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "l": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env10 ])",
              "envs": {
                "env10": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env6": {
          "l": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env7": {
          "l": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let aa =\n    match [9] with\n    | [] -> []\n    | _::[] -> ((l)[@env4 ])\n    | _ ->\n        ((let (a, b) = split l in\n          let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n        [@env6 ][@env5 ]) in\n  let bb = ((merge_sort)[@env3 ]) [7] in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "l": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env9 ])",
              "envs": {
                "env9": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env6": {
          "l": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        }
      }
    },
    "step": [ "Match" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let aa = ((l)[@env4 ]) in\n  let bb = ((merge_sort)[@env3 ]) [7] in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "l": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let aa = [9] in\n  let bb = ((merge_sort)[@env3 ]) [7] in ((merge)[@env2 ]) aa bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "Let" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = ((let bb = ((merge_sort)[@env3 ]) [7] in ((merge)[@env2 ]) aa bb)\n  [@env4 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "aa": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let bb = ((merge_sort)[@env4 ]) [7] in ((((merge)[@env2 ]) aa bb)[@env3 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "aa": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let bb = ((merge_sort)[@env4 ]) [7] in ((merge)[@env3 ]) ((aa)[@env2 ]) bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "aa": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env3": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = let bb = ((merge_sort)[@env3 ]) [7] in ((merge)[@env2 ]) [9] bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "SubstFun" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let bb =\n    ((fun l ->\n        ((match l with\n          | [] -> []\n          | _::[] -> l\n          | _ ->\n              let (a, b) = split l in\n              let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n        [@env3 ]))[@env4 ]) [7] in\n  ((merge)[@env2 ]) [9] bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let bb =\n    (fun l ->\n       ((match l with\n         | [] -> []\n         | _::[] -> l\n         | _ ->\n             let (a, b) = split l in\n             let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n       [@env4 ][@env3 ])) [7] in\n  ((merge)[@env2 ]) [9] bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "SubstCombine" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let bb =\n    (fun l ->\n       ((match l with\n         | [] -> []\n         | _::[] -> l\n         | _ ->\n             let (a, b) = split l in\n             let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n       [@env3 ])) [7] in\n  ((merge)[@env2 ]) [9] bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let bb =\n    (fun l ->\n       match l with\n       | [] -> []\n       | _::[] -> l\n       | _ ->\n           ((let (a, b) = split l in\n             let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n           [@env3 ])) [7] in\n  ((merge)[@env2 ]) [9] bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "ApplyFunComplete" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let bb =\n    ((match l with\n      | [] -> []\n      | _::[] -> l\n      | _ ->\n          ((let (a, b) = split l in\n            let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n          [@env3 ]))\n    [@env4 ]) in\n  ((merge)[@env2 ]) [9] bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env4": {
          "l": { "corec": [], "expr": { "expr": "[7]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let bb =\n    match ((l)[@env6 ]) with\n    | [] -> []\n    | _::[] -> ((l)[@env3 ])\n    | _ ->\n        ((let (a, b) = split l in\n          let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n        [@env5 ][@env4 ]) in\n  ((merge)[@env2 ]) [9] bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "l": { "corec": [], "expr": { "expr": "[7]", "envs": {} } }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env5": {
          "l": { "corec": [], "expr": { "expr": "[7]", "envs": {} } }
        },
        "env6": {
          "l": { "corec": [], "expr": { "expr": "[7]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  let bb =\n    match [7] with\n    | [] -> []\n    | _::[] -> ((l)[@env3 ])\n    | _ ->\n        ((let (a, b) = split l in\n          let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n        [@env5 ][@env4 ]) in\n  ((merge)[@env2 ]) [9] bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "l": { "corec": [], "expr": { "expr": "[7]", "envs": {} } }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env5": {
          "l": { "corec": [], "expr": { "expr": "[7]", "envs": {} } }
        }
      }
    },
    "step": [ "Match" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = let bb = ((l)[@env3 ]) in ((merge)[@env2 ]) [9] bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "l": { "corec": [], "expr": { "expr": "[7]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = let bb = [7] in ((merge)[@env2 ]) [9] bb in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "Let" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = ((((merge)[@env2 ]) [9] bb)[@env3 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "bb": { "corec": [], "expr": { "expr": "[7]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = ((merge)[@env3 ]) [9] ((bb)[@env2 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "bb": { "corec": [], "expr": { "expr": "[7]", "envs": {} } }
        },
        "env3": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = ((merge)[@env2 ]) [9] [7] in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstFun" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  ((fun l1 ->\n      fun l2 ->\n        match (l1, l2) with\n        | (p1::q1, p2::q2) ->\n            if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n        | (_, []) -> l1\n        | ([], _) -> l2)[@env2 ]) [9] [7] in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  (fun l1 ->\n     ((fun l2 ->\n         match (l1, l2) with\n         | (p1::q1, p2::q2) ->\n             if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n         | (_, []) -> l1\n         | ([], _) -> l2)\n     [@env2 ])) [9] [7] in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  (fun l1 ->\n     fun l2 ->\n       ((match (l1, l2) with\n         | (p1::q1, p2::q2) ->\n             if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n         | (_, []) -> l1\n         | ([], _) -> l2)\n       [@env2 ])) [9] [7] in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  (fun l1 ->\n     fun l2 ->\n       match (l1, l2) with\n       | (p1::q1, p2::q2) ->\n           ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n           [@env2 ])\n       | (_, []) -> l1\n       | ([], _) -> l2) [9] [7] in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "ApplyFunComplete" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  ((match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n        [@env2 ])\n    | (_, []) -> l1\n    | ([], _) -> l2)\n  [@env3 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "l2": { "corec": [], "expr": { "expr": "[7]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  match (((l1, l2))[@env6 ]) with\n  | (p1::q1, p2::q2) ->\n      ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n      [@env3 ][@env2 ])\n  | (_, []) -> ((l1)[@env4 ])\n  | ([], _) -> ((l2)[@env5 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "l2": { "corec": [], "expr": { "expr": "[7]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env4": {
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env5": {
          "l2": { "corec": [], "expr": { "expr": "[7]", "envs": {} } }
        },
        "env6": {
          "l2": { "corec": [], "expr": { "expr": "[7]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  match (((l1)[@env6 ]), ((l2)[@env7 ])) with\n  | (p1::q1, p2::q2) ->\n      ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n      [@env3 ][@env2 ])\n  | (_, []) -> ((l1)[@env4 ])\n  | ([], _) -> ((l2)[@env5 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "l2": { "corec": [], "expr": { "expr": "[7]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env4": {
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env5": {
          "l2": { "corec": [], "expr": { "expr": "[7]", "envs": {} } }
        },
        "env6": {
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env7": {
          "l2": { "corec": [], "expr": { "expr": "[7]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  match ([9], ((l2)[@env6 ])) with\n  | (p1::q1, p2::q2) ->\n      ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n      [@env3 ][@env2 ])\n  | (_, []) -> ((l1)[@env4 ])\n  | ([], _) -> ((l2)[@env5 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "l2": { "corec": [], "expr": { "expr": "[7]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env4": {
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env5": {
          "l2": { "corec": [], "expr": { "expr": "[7]", "envs": {} } }
        },
        "env6": {
          "l2": { "corec": [], "expr": { "expr": "[7]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  match ([9], [7]) with\n  | (p1::q1, p2::q2) ->\n      ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n      [@env3 ][@env2 ])\n  | (_, []) -> ((l1)[@env4 ])\n  | ([], _) -> ((l2)[@env5 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "l2": { "corec": [], "expr": { "expr": "[7]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env4": {
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env5": {
          "l2": { "corec": [], "expr": { "expr": "[7]", "envs": {} } }
        }
      }
    },
    "step": [ "Match" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n  [@env4 ][@env3 ][@env2 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "l2": { "corec": [], "expr": { "expr": "[7]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env4": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "q1": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "7", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "9", "envs": {} } }
        }
      }
    },
    "step": [ "SubstCombine" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n  [@env3 ][@env2 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "q1": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "7", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "9", "envs": {} } },
          "l2": { "corec": [], "expr": { "expr": "[7]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstCombine" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n  [@env2 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "q1": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "7", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "9", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[7]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  if ((p1 < p2)[@env4 ])\n  then ((p1 :: (merge q1 l2))[@env3 ])\n  else ((p2 :: (merge l1 q2))[@env2 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "7", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env3": {
          "q1": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "9", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[7]", "envs": {} } }
        },
        "env4": {
          "p2": { "corec": [], "expr": { "expr": "7", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "9", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  if ((p1)[@env4 ]) < ((p2)[@env5 ])\n  then ((p1 :: (merge q1 l2))[@env3 ])\n  else ((p2 :: (merge l1 q2))[@env2 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "7", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env3": {
          "q1": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "9", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[7]", "envs": {} } }
        },
        "env4": {
          "p1": { "corec": [], "expr": { "expr": "9", "envs": {} } }
        },
        "env5": {
          "p2": { "corec": [], "expr": { "expr": "7", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  if 9 < ((p2)[@env4 ])\n  then ((p1 :: (merge q1 l2))[@env3 ])\n  else ((p2 :: (merge l1 q2))[@env2 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "7", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env3": {
          "q1": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "9", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[7]", "envs": {} } }
        },
        "env4": {
          "p2": { "corec": [], "expr": { "expr": "7", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  if 9 < 7\n  then ((p1 :: (merge q1 l2))[@env3 ])\n  else ((p2 :: (merge l1 q2))[@env2 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "7", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env3": {
          "q1": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "9", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[7]", "envs": {} } }
        }
      }
    },
    "step": [ "ApplyFunRuntime" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa =\n  if false\n  then ((p1 :: (merge q1 l2))[@env3 ])\n  else ((p2 :: (merge l1 q2))[@env2 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "7", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env3": {
          "q1": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "9", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[7]", "envs": {} } }
        }
      }
    },
    "step": [ "If" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = ((p2 :: (merge l1 q2))[@env2 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "7", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = ((p2 :: (merge l1 q2))[@env2 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "7", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = ((p2)[@env2 ]) :: ((merge l1 q2)[@env3 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "p2": { "corec": [], "expr": { "expr": "7", "envs": {} } }
        },
        "env3": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = ((p2)[@env2 ]) :: (((merge)[@env5 ]) ((l1)[@env3 ]) ((q2)[@env4 ])) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "p2": { "corec": [], "expr": { "expr": "7", "envs": {} } }
        },
        "env3": {
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env4": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env5": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = 7 :: (((merge)[@env4 ]) ((l1)[@env2 ]) ((q2)[@env3 ])) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env3": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env4": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = 7 :: (((merge)[@env3 ]) [9] ((q2)[@env2 ])) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env3": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = 7 :: (((merge)[@env2 ]) [9] []) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstFun" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = 7 ::\n  (((fun l1 ->\n       fun l2 ->\n         match (l1, l2) with\n         | (p1::q1, p2::q2) ->\n             if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n         | (_, []) -> l1\n         | ([], _) -> l2)[@env2 ]) [9] []) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = 7 ::\n  ((fun l1 ->\n      ((fun l2 ->\n          match (l1, l2) with\n          | (p1::q1, p2::q2) ->\n              if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n          | (_, []) -> l1\n          | ([], _) -> l2)\n      [@env2 ])) [9] []) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = 7 ::\n  ((fun l1 ->\n      fun l2 ->\n        ((match (l1, l2) with\n          | (p1::q1, p2::q2) ->\n              if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n          | (_, []) -> l1\n          | ([], _) -> l2)\n        [@env2 ])) [9] []) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = 7 ::\n  ((fun l1 ->\n      fun l2 ->\n        match (l1, l2) with\n        | (p1::q1, p2::q2) ->\n            ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n            [@env2 ])\n        | (_, []) -> l1\n        | ([], _) -> l2) [9] []) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "ApplyFunComplete" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = 7 ::\n  ((match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n        [@env2 ])\n    | (_, []) -> l1\n    | ([], _) -> l2)\n  [@env3 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = 7 ::\n  (match (((l1, l2))[@env6 ]) with\n   | (p1::q1, p2::q2) ->\n       ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n       [@env3 ][@env2 ])\n   | (_, []) -> ((l1)[@env4 ])\n   | ([], _) -> ((l2)[@env5 ])) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env4": {
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env5": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env6": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = 7 ::\n  (match (((l1)[@env6 ]), ((l2)[@env7 ])) with\n   | (p1::q1, p2::q2) ->\n       ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n       [@env3 ][@env2 ])\n   | (_, []) -> ((l1)[@env4 ])\n   | ([], _) -> ((l2)[@env5 ])) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env4": {
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env5": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env6": {
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env7": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = 7 ::\n  (match ([9], ((l2)[@env6 ])) with\n   | (p1::q1, p2::q2) ->\n       ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n       [@env3 ][@env2 ])\n   | (_, []) -> ((l1)[@env4 ])\n   | ([], _) -> ((l2)[@env5 ])) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env4": {
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env5": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env6": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = 7 ::\n  (match ([9], []) with\n   | (p1::q1, p2::q2) ->\n       ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n       [@env3 ][@env2 ])\n   | (_, []) -> ((l1)[@env4 ])\n   | ([], _) -> ((l2)[@env5 ])) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env4": {
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env5": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "Match" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = 7 :: ((l1)[@env2 ]) in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let aa = [7; 9] in\nlet bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env2 ])",
              "envs": {
                "env2": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "Let" ]
  },
  {
    "current_expression": {
      "expr":
        "((let bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) aa bb)[@env2 ])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env2": {
          "aa": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb = ((merge_sort)[@env2 ]) [8; 6] in ((((merge)[@env0 ]) aa bb)[@env1 ])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "aa": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb = ((merge_sort)[@env2 ]) [8; 6] in ((merge)[@env1 ]) ((aa)[@env0 ]) bb",
      "envs": {
        "env0": {
          "aa": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb = ((merge_sort)[@env1 ]) [8; 6] in ((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env2 ])",
              "envs": {
                "env2": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "SubstFun" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  ((fun l ->\n      ((match l with\n        | [] -> []\n        | _::[] -> l\n        | _ ->\n            let (a, b) = split l in\n            let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n      [@env1 ]))[@env2 ]) [8; 6] in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  (fun l ->\n     ((match l with\n       | [] -> []\n       | _::[] -> l\n       | _ ->\n           let (a, b) = split l in\n           let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n     [@env2 ][@env1 ])) [8; 6] in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "SubstCombine" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  (fun l ->\n     ((match l with\n       | [] -> []\n       | _::[] -> l\n       | _ ->\n           let (a, b) = split l in\n           let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n     [@env1 ])) [8; 6] in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env2 ])",
              "envs": {
                "env2": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  (fun l ->\n     match l with\n     | [] -> []\n     | _::[] -> l\n     | _ ->\n         ((let (a, b) = split l in\n           let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n         [@env1 ])) [8; 6] in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env2 ])",
              "envs": {
                "env2": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "ApplyFunComplete" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        ((let (a, b) = split l in\n          let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n        [@env1 ]))\n  [@env2 ]) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "l": { "corec": [], "expr": { "expr": "[8; 6]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  match ((l)[@env4 ]) with\n  | [] -> []\n  | _::[] -> ((l)[@env1 ])\n  | _ ->\n      ((let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n      [@env3 ][@env2 ]) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "l": { "corec": [], "expr": { "expr": "[8; 6]", "envs": {} } }
        },
        "env2": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "l": { "corec": [], "expr": { "expr": "[8; 6]", "envs": {} } }
        },
        "env4": {
          "l": { "corec": [], "expr": { "expr": "[8; 6]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  match [8; 6] with\n  | [] -> []\n  | _::[] -> ((l)[@env1 ])\n  | _ ->\n      ((let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n      [@env3 ][@env2 ]) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "l": { "corec": [], "expr": { "expr": "[8; 6]", "envs": {} } }
        },
        "env2": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "l": { "corec": [], "expr": { "expr": "[8; 6]", "envs": {} } }
        }
      }
    },
    "step": [ "Match" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  ((let (a, b) = split l in\n    let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env2 ][@env1 ]) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "l": { "corec": [], "expr": { "expr": "[8; 6]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstCombine" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  ((let (a, b) = split l in\n    let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env1 ]) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env2 ])",
              "envs": {
                "env2": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l": { "corec": [], "expr": { "expr": "[8; 6]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) = ((split l)[@env2 ]) in\n  ((let aa = merge_sort a in let bb = merge_sort b in merge aa bb)[@env1 ]) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "l": { "corec": [], "expr": { "expr": "[8; 6]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) = ((split l)[@env3 ]) in\n  let aa = ((merge_sort a)[@env2 ]) in\n  ((let bb = merge_sort b in merge aa bb)[@env1 ]) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "l": { "corec": [], "expr": { "expr": "[8; 6]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) = ((split l)[@env4 ]) in\n  let aa = ((merge_sort a)[@env3 ]) in\n  let bb = ((merge_sort b)[@env2 ]) in ((merge aa bb)[@env1 ]) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "l": { "corec": [], "expr": { "expr": "[8; 6]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) = ((split l)[@env4 ]) in\n  let aa = ((merge_sort a)[@env3 ]) in\n  let bb = ((merge_sort b)[@env2 ]) in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "l": { "corec": [], "expr": { "expr": "[8; 6]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) = ((split l)[@env4 ]) in\n  let aa = ((merge_sort a)[@env3 ]) in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "l": { "corec": [], "expr": { "expr": "[8; 6]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) = ((split l)[@env4 ]) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "l": { "corec": [], "expr": { "expr": "[8; 6]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) = ((split)[@env5 ]) ((l)[@env4 ]) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "l": { "corec": [], "expr": { "expr": "[8; 6]", "envs": {} } }
        },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) = ((split)[@env4 ]) [8; 6] in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstFun" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) =\n    ((fun l ->\n        match l with\n        | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n        | p::[] -> ([p], [])\n        | [] -> ([], []))[@env4 ]) [8; 6] in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) =\n    (fun l ->\n       ((match l with\n         | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n         | p::[] -> ([p], [])\n         | [] -> ([], []))\n       [@env4 ])) [8; 6] in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) =\n    (fun l ->\n       match l with\n       | p::q::r -> ((let (a, b) = split r in ((p :: a), (q :: b)))[@env4 ])\n       | p::[] -> ([p], [])\n       | [] -> ([], [])) [8; 6] in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "ApplyFunComplete" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) =\n    ((match l with\n      | p::q::r -> ((let (a, b) = split r in ((p :: a), (q :: b)))[@env4 ])\n      | p::[] -> ([p], [])\n      | [] -> ([], []))\n    [@env5 ]) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        },
        "env5": {
          "l": { "corec": [], "expr": { "expr": "[8; 6]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) =\n    match ((l)[@env5 ]) with\n    | p::q::r -> ((let (a, b) = split r in ((p :: a), (q :: b)))[@env4 ])\n    | p::[] -> ([p], [])\n    | [] -> ([], []) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        },
        "env5": {
          "l": { "corec": [], "expr": { "expr": "[8; 6]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) =\n    match [8; 6] with\n    | p::q::r -> ((let (a, b) = split r in ((p :: a), (q :: b)))[@env4 ])\n    | p::[] -> ([p], [])\n    | [] -> ([], []) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "Match" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) = ((let (a, b) = split r in ((p :: a), (q :: b)))\n    [@env5 ][@env4 ]) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        },
        "env5": {
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "q": { "corec": [], "expr": { "expr": "6", "envs": {} } },
          "p": { "corec": [], "expr": { "expr": "8", "envs": {} } }
        }
      }
    },
    "step": [ "SubstCombine" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) = ((let (a, b) = split r in ((p :: a), (q :: b)))[@env4 ]) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "q": { "corec": [], "expr": { "expr": "6", "envs": {} } },
          "p": { "corec": [], "expr": { "expr": "8", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) =\n    let (a, b) = ((split r)[@env5 ]) in ((((p :: a), (q :: b)))[@env4 ]) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "q": { "corec": [], "expr": { "expr": "6", "envs": {} } },
          "p": { "corec": [], "expr": { "expr": "8", "envs": {} } }
        },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) =\n    let (a, b) = ((split r)[@env6 ]) in\n    (((p :: a)[@env4 ]), ((q :: b)[@env5 ])) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": { "p": { "corec": [], "expr": { "expr": "8", "envs": {} } } },
        "env5": { "q": { "corec": [], "expr": { "expr": "6", "envs": {} } } },
        "env6": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) =\n    let (a, b) = ((split r)[@env6 ]) in\n    (((p :: a)[@env4 ]), ((q :: b)[@env5 ])) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": { "p": { "corec": [], "expr": { "expr": "8", "envs": {} } } },
        "env5": { "q": { "corec": [], "expr": { "expr": "6", "envs": {} } } },
        "env6": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) =\n    let (a, b) = ((split r)[@env6 ]) in\n    ((((p)[@env4 ]) :: a), ((q :: b)[@env5 ])) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": { "p": { "corec": [], "expr": { "expr": "8", "envs": {} } } },
        "env5": { "q": { "corec": [], "expr": { "expr": "6", "envs": {} } } },
        "env6": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) =\n    let (a, b) = ((split r)[@env6 ]) in\n    ((((p)[@env4 ]) :: a), ((q :: b)[@env5 ])) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": { "p": { "corec": [], "expr": { "expr": "8", "envs": {} } } },
        "env5": { "q": { "corec": [], "expr": { "expr": "6", "envs": {} } } },
        "env6": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) =\n    let (a, b) = ((split r)[@env6 ]) in\n    ((((p)[@env4 ]) :: a), (((q)[@env5 ]) :: b)) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": { "p": { "corec": [], "expr": { "expr": "8", "envs": {} } } },
        "env5": { "q": { "corec": [], "expr": { "expr": "6", "envs": {} } } },
        "env6": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) =\n    let (a, b) = ((split)[@env7 ]) ((r)[@env6 ]) in\n    ((((p)[@env4 ]) :: a), (((q)[@env5 ]) :: b)) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env9 ])",
              "envs": {
                "env9": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": { "p": { "corec": [], "expr": { "expr": "8", "envs": {} } } },
        "env5": { "q": { "corec": [], "expr": { "expr": "6", "envs": {} } } },
        "env6": {
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env7": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) =\n    let (a, b) = ((split)[@env6 ]) ((r)[@env5 ]) in\n    ((8 :: a), (((q)[@env4 ]) :: b)) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": { "q": { "corec": [], "expr": { "expr": "6", "envs": {} } } },
        "env5": {
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env6": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) =\n    let (a, b) = ((split)[@env5 ]) ((r)[@env4 ]) in ((8 :: a), (6 :: b)) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "r": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env5": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) = let (a, b) = ((split)[@env4 ]) [] in ((8 :: a), (6 :: b)) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstFun" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) =\n    let (a, b) =\n      ((fun l ->\n          match l with\n          | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n          | p::[] -> ([p], [])\n          | [] -> ([], []))[@env4 ]) [] in\n    ((8 :: a), (6 :: b)) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) =\n    let (a, b) =\n      (fun l ->\n         ((match l with\n           | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n           | p::[] -> ([p], [])\n           | [] -> ([], []))\n         [@env4 ])) [] in\n    ((8 :: a), (6 :: b)) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) =\n    let (a, b) =\n      (fun l ->\n         match l with\n         | p::q::r -> ((let (a, b) = split r in ((p :: a), (q :: b)))\n             [@env4 ])\n         | p::[] -> ([p], [])\n         | [] -> ([], [])) [] in\n    ((8 :: a), (6 :: b)) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "ApplyFunComplete" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) =\n    let (a, b) =\n      ((match l with\n        | p::q::r -> ((let (a, b) = split r in ((p :: a), (q :: b)))[@env4 ])\n        | p::[] -> ([p], [])\n        | [] -> ([], []))\n      [@env5 ]) in\n    ((8 :: a), (6 :: b)) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        },
        "env5": {
          "l": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) =\n    let (a, b) =\n      match ((l)[@env5 ]) with\n      | p::q::r -> ((let (a, b) = split r in ((p :: a), (q :: b)))[@env4 ])\n      | p::[] -> ([p], [])\n      | [] -> ([], []) in\n    ((8 :: a), (6 :: b)) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        },
        "env5": {
          "l": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) =\n    let (a, b) =\n      match [] with\n      | p::q::r -> ((let (a, b) = split r in ((p :: a), (q :: b)))[@env4 ])\n      | p::[] -> ([p], [])\n      | [] -> ([], []) in\n    ((8 :: a), (6 :: b)) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "Match" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) = let (a, b) = ([], []) in ((8 :: a), (6 :: b)) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "Let" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) = ((((8 :: a), (6 :: b)))[@env4 ]) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "b": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "a": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) = (((8 :: a)[@env4 ]), ((6 :: b)[@env5 ])) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "a": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env5": {
          "b": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) = (((8 :: a)[@env4 ]), ((6 :: b)[@env5 ])) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "a": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env5": {
          "b": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) = ((8 :: ((a)[@env4 ])), ((6 :: b)[@env5 ])) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "a": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env5": {
          "b": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) = ((8 :: ((a)[@env4 ])), ((6 :: b)[@env5 ])) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "a": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env5": {
          "b": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) = ((8 :: ((a)[@env4 ])), (6 :: ((b)[@env5 ]))) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "a": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env5": {
          "b": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) = ([8], (6 :: ((b)[@env4 ]))) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "b": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let (a, b) = ([8], [6]) in\n  let aa = ((merge_sort)[@env3 ]) a in\n  let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "Let" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  ((let aa = ((merge_sort)[@env3 ]) a in\n    let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb)\n  [@env4 ]) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "b": { "corec": [], "expr": { "expr": "[6]", "envs": {} } },
          "a": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let aa = ((((merge_sort)[@env4 ]) a)[@env5 ]) in\n  ((let bb = ((merge_sort)[@env2 ]) b in ((merge)[@env1 ]) aa bb)[@env3 ]) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "b": { "corec": [], "expr": { "expr": "[6]", "envs": {} } }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "a": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let aa = ((((merge_sort)[@env4 ]) a)[@env5 ]) in\n  let bb = ((((merge_sort)[@env2 ]) b)[@env3 ]) in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "b": { "corec": [], "expr": { "expr": "[6]", "envs": {} } }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "a": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let aa = ((((merge_sort)[@env4 ]) a)[@env5 ]) in\n  let bb = ((merge_sort)[@env3 ]) ((b)[@env2 ]) in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "b": { "corec": [], "expr": { "expr": "[6]", "envs": {} } }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env5": {
          "a": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let aa = ((merge_sort)[@env5 ]) ((a)[@env4 ]) in\n  let bb = ((merge_sort)[@env3 ]) ((b)[@env2 ]) in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "b": { "corec": [], "expr": { "expr": "[6]", "envs": {} } }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env4": {
          "a": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env5": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let aa = ((merge_sort)[@env4 ]) ((a)[@env3 ]) in\n  let bb = ((merge_sort)[@env2 ]) [6] in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "a": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let aa = ((merge_sort)[@env3 ]) [8] in\n  let bb = ((merge_sort)[@env2 ]) [6] in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "SubstFun" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let aa =\n    ((fun l ->\n        ((match l with\n          | [] -> []\n          | _::[] -> l\n          | _ ->\n              let (a, b) = split l in\n              let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n        [@env3 ]))[@env4 ]) [8] in\n  let bb = ((merge_sort)[@env2 ]) [6] in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let aa =\n    (fun l ->\n       ((match l with\n         | [] -> []\n         | _::[] -> l\n         | _ ->\n             let (a, b) = split l in\n             let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n       [@env4 ][@env3 ])) [8] in\n  let bb = ((merge_sort)[@env2 ]) [6] in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env4": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "SubstCombine" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let aa =\n    (fun l ->\n       ((match l with\n         | [] -> []\n         | _::[] -> l\n         | _ ->\n             let (a, b) = split l in\n             let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n       [@env3 ])) [8] in\n  let bb = ((merge_sort)[@env2 ]) [6] in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let aa =\n    (fun l ->\n       match l with\n       | [] -> []\n       | _::[] -> l\n       | _ ->\n           ((let (a, b) = split l in\n             let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n           [@env3 ])) [8] in\n  let bb = ((merge_sort)[@env2 ]) [6] in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "ApplyFunComplete" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let aa =\n    ((match l with\n      | [] -> []\n      | _::[] -> l\n      | _ ->\n          ((let (a, b) = split l in\n            let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n          [@env3 ]))\n    [@env4 ]) in\n  let bb = ((merge_sort)[@env2 ]) [6] in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env4": {
          "l": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let aa =\n    match ((l)[@env6 ]) with\n    | [] -> []\n    | _::[] -> ((l)[@env3 ])\n    | _ ->\n        ((let (a, b) = split l in\n          let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n        [@env5 ][@env4 ]) in\n  let bb = ((merge_sort)[@env2 ]) [6] in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "l": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env8 ])",
              "envs": {
                "env8": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env5": {
          "l": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env6": {
          "l": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let aa =\n    match [8] with\n    | [] -> []\n    | _::[] -> ((l)[@env3 ])\n    | _ ->\n        ((let (a, b) = split l in\n          let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n        [@env5 ][@env4 ]) in\n  let bb = ((merge_sort)[@env2 ]) [6] in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "l": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env4": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env7 ])",
              "envs": {
                "env7": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env5": {
          "l": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "Match" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let aa = ((l)[@env3 ]) in\n  let bb = ((merge_sort)[@env2 ]) [6] in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "l": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let aa = [8] in\n  let bb = ((merge_sort)[@env2 ]) [6] in ((merge)[@env1 ]) aa bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "Let" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb = ((let bb = ((merge_sort)[@env2 ]) [6] in ((merge)[@env1 ]) aa bb)\n  [@env3 ]) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        },
        "env3": {
          "aa": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let bb = ((merge_sort)[@env3 ]) [6] in ((((merge)[@env1 ]) aa bb)[@env2 ]) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "aa": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let bb = ((merge_sort)[@env3 ]) [6] in ((merge)[@env2 ]) ((aa)[@env1 ]) bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "aa": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb = let bb = ((merge_sort)[@env2 ]) [6] in ((merge)[@env1 ]) [8] bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "SubstFun" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let bb =\n    ((fun l ->\n        ((match l with\n          | [] -> []\n          | _::[] -> l\n          | _ ->\n              let (a, b) = split l in\n              let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n        [@env2 ]))[@env3 ]) [6] in\n  ((merge)[@env1 ]) [8] bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let bb =\n    (fun l ->\n       ((match l with\n         | [] -> []\n         | _::[] -> l\n         | _ ->\n             let (a, b) = split l in\n             let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n       [@env3 ][@env2 ])) [6] in\n  ((merge)[@env1 ]) [8] bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "step": [ "SubstCombine" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let bb =\n    (fun l ->\n       ((match l with\n         | [] -> []\n         | _::[] -> l\n         | _ ->\n             let (a, b) = split l in\n             let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n       [@env2 ])) [6] in\n  ((merge)[@env1 ]) [8] bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let bb =\n    (fun l ->\n       match l with\n       | [] -> []\n       | _::[] -> l\n       | _ ->\n           ((let (a, b) = split l in\n             let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n           [@env2 ])) [6] in\n  ((merge)[@env1 ]) [8] bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env3 ])",
              "envs": {
                "env3": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "ApplyFunComplete" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let bb =\n    ((match l with\n      | [] -> []\n      | _::[] -> l\n      | _ ->\n          ((let (a, b) = split l in\n            let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n          [@env2 ]))\n    [@env3 ]) in\n  ((merge)[@env1 ]) [8] bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env4 ])",
              "envs": {
                "env4": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env3": {
          "l": { "corec": [], "expr": { "expr": "[6]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let bb =\n    match ((l)[@env5 ]) with\n    | [] -> []\n    | _::[] -> ((l)[@env2 ])\n    | _ ->\n        ((let (a, b) = split l in\n          let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n        [@env4 ][@env3 ]) in\n  ((merge)[@env1 ]) [8] bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "l": { "corec": [], "expr": { "expr": "[6]", "envs": {} } }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env6 ])",
              "envs": {
                "env6": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env4": {
          "l": { "corec": [], "expr": { "expr": "[6]", "envs": {} } }
        },
        "env5": {
          "l": { "corec": [], "expr": { "expr": "[6]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  let bb =\n    match [6] with\n    | [] -> []\n    | _::[] -> ((l)[@env2 ])\n    | _ ->\n        ((let (a, b) = split l in\n          let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n        [@env4 ][@env3 ]) in\n  ((merge)[@env1 ]) [8] bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "l": { "corec": [], "expr": { "expr": "[6]", "envs": {} } }
        },
        "env3": {
          "split": {
            "corec": [ "split" ],
            "expr": {
              "expr":
                "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
              "envs": {}
            }
          },
          "merge_sort": {
            "corec": [ "merge_sort" ],
            "expr": {
              "expr":
                "fun l ->\n  ((match l with\n    | [] -> []\n    | _::[] -> l\n    | _ ->\n        let (a, b) = split l in\n        let aa = merge_sort a in let bb = merge_sort b in merge aa bb)\n  [@env5 ])",
              "envs": {
                "env5": {
                  "split": {
                    "corec": [ "split" ],
                    "expr": {
                      "expr":
                        "fun l ->\n  match l with\n  | p::q::r -> let (a, b) = split r in ((p :: a), (q :: b))\n  | p::[] -> ([p], [])\n  | [] -> ([], [])",
                      "envs": {}
                    }
                  },
                  "merge": {
                    "corec": [ "merge" ],
                    "expr": {
                      "expr":
                        "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
                      "envs": {}
                    }
                  }
                }
              }
            }
          },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env4": {
          "l": { "corec": [], "expr": { "expr": "[6]", "envs": {} } }
        }
      }
    },
    "step": [ "Match" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb = let bb = ((l)[@env2 ]) in ((merge)[@env1 ]) [8] bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "l": { "corec": [], "expr": { "expr": "[6]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb = let bb = [6] in ((merge)[@env1 ]) [8] bb in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "Let" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb = ((((merge)[@env1 ]) [8] bb)[@env2 ]) in ((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "bb": { "corec": [], "expr": { "expr": "[6]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb = ((merge)[@env2 ]) [8] ((bb)[@env1 ]) in ((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "bb": { "corec": [], "expr": { "expr": "[6]", "envs": {} } }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb = ((merge)[@env1 ]) [8] [6] in ((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstFun" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  ((fun l1 ->\n      fun l2 ->\n        match (l1, l2) with\n        | (p1::q1, p2::q2) ->\n            if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n        | (_, []) -> l1\n        | ([], _) -> l2)[@env1 ]) [8] [6] in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  (fun l1 ->\n     ((fun l2 ->\n         match (l1, l2) with\n         | (p1::q1, p2::q2) ->\n             if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n         | (_, []) -> l1\n         | ([], _) -> l2)\n     [@env1 ])) [8] [6] in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  (fun l1 ->\n     fun l2 ->\n       ((match (l1, l2) with\n         | (p1::q1, p2::q2) ->\n             if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n         | (_, []) -> l1\n         | ([], _) -> l2)\n       [@env1 ])) [8] [6] in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  (fun l1 ->\n     fun l2 ->\n       match (l1, l2) with\n       | (p1::q1, p2::q2) ->\n           ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n           [@env1 ])\n       | (_, []) -> l1\n       | ([], _) -> l2) [8] [6] in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "ApplyFunComplete" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  ((match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n        [@env1 ])\n    | (_, []) -> l1\n    | ([], _) -> l2)\n  [@env2 ]) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "l2": { "corec": [], "expr": { "expr": "[6]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  match (((l1, l2))[@env5 ]) with\n  | (p1::q1, p2::q2) ->\n      ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n      [@env2 ][@env1 ])\n  | (_, []) -> ((l1)[@env3 ])\n  | ([], _) -> ((l2)[@env4 ]) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "l2": { "corec": [], "expr": { "expr": "[6]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env3": {
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env4": {
          "l2": { "corec": [], "expr": { "expr": "[6]", "envs": {} } }
        },
        "env5": {
          "l2": { "corec": [], "expr": { "expr": "[6]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  match (((l1)[@env5 ]), ((l2)[@env6 ])) with\n  | (p1::q1, p2::q2) ->\n      ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n      [@env2 ][@env1 ])\n  | (_, []) -> ((l1)[@env3 ])\n  | ([], _) -> ((l2)[@env4 ]) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "l2": { "corec": [], "expr": { "expr": "[6]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env3": {
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env4": {
          "l2": { "corec": [], "expr": { "expr": "[6]", "envs": {} } }
        },
        "env5": {
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env6": {
          "l2": { "corec": [], "expr": { "expr": "[6]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  match ([8], ((l2)[@env5 ])) with\n  | (p1::q1, p2::q2) ->\n      ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n      [@env2 ][@env1 ])\n  | (_, []) -> ((l1)[@env3 ])\n  | ([], _) -> ((l2)[@env4 ]) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "l2": { "corec": [], "expr": { "expr": "[6]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env3": {
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env4": {
          "l2": { "corec": [], "expr": { "expr": "[6]", "envs": {} } }
        },
        "env5": {
          "l2": { "corec": [], "expr": { "expr": "[6]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  match ([8], [6]) with\n  | (p1::q1, p2::q2) ->\n      ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n      [@env2 ][@env1 ])\n  | (_, []) -> ((l1)[@env3 ])\n  | ([], _) -> ((l2)[@env4 ]) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "l2": { "corec": [], "expr": { "expr": "[6]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env3": {
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env4": {
          "l2": { "corec": [], "expr": { "expr": "[6]", "envs": {} } }
        }
      }
    },
    "step": [ "Match" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb = ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n  [@env3 ][@env2 ][@env1 ]) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "l2": { "corec": [], "expr": { "expr": "[6]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env3": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "q1": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "6", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "8", "envs": {} } }
        }
      }
    },
    "step": [ "SubstCombine" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb = ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n  [@env2 ][@env1 ]) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "q1": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "6", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "8", "envs": {} } },
          "l2": { "corec": [], "expr": { "expr": "[6]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstCombine" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb = ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n  [@env1 ]) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "q1": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "6", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "8", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[6]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  if ((p1 < p2)[@env3 ])\n  then ((p1 :: (merge q1 l2))[@env2 ])\n  else ((p2 :: (merge l1 q2))[@env1 ]) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "6", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env2": {
          "q1": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "8", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[6]", "envs": {} } }
        },
        "env3": {
          "p2": { "corec": [], "expr": { "expr": "6", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "8", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  if ((p1)[@env3 ]) < ((p2)[@env4 ])\n  then ((p1 :: (merge q1 l2))[@env2 ])\n  else ((p2 :: (merge l1 q2))[@env1 ]) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "6", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env2": {
          "q1": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "8", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[6]", "envs": {} } }
        },
        "env3": {
          "p1": { "corec": [], "expr": { "expr": "8", "envs": {} } }
        },
        "env4": {
          "p2": { "corec": [], "expr": { "expr": "6", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  if 8 < ((p2)[@env3 ])\n  then ((p1 :: (merge q1 l2))[@env2 ])\n  else ((p2 :: (merge l1 q2))[@env1 ]) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "6", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env2": {
          "q1": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "8", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[6]", "envs": {} } }
        },
        "env3": {
          "p2": { "corec": [], "expr": { "expr": "6", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  if 8 < 6\n  then ((p1 :: (merge q1 l2))[@env2 ])\n  else ((p2 :: (merge l1 q2))[@env1 ]) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "6", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env2": {
          "q1": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "8", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[6]", "envs": {} } }
        }
      }
    },
    "step": [ "ApplyFunRuntime" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb =\n  if false\n  then ((p1 :: (merge q1 l2))[@env2 ])\n  else ((p2 :: (merge l1 q2))[@env1 ]) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "6", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env2": {
          "q1": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "8", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[6]", "envs": {} } }
        }
      }
    },
    "step": [ "If" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb = ((p2 :: (merge l1 q2))[@env1 ]) in ((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "6", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb = ((p2 :: (merge l1 q2))[@env1 ]) in ((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "6", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb = ((p2)[@env1 ]) :: ((merge l1 q2)[@env2 ]) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "p2": { "corec": [], "expr": { "expr": "6", "envs": {} } }
        },
        "env2": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb = ((p2)[@env1 ]) :: (((merge)[@env4 ]) ((l1)[@env2 ]) ((q2)[@env3 ])) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "p2": { "corec": [], "expr": { "expr": "6", "envs": {} } }
        },
        "env2": {
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env3": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env4": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb = 6 :: (((merge)[@env3 ]) ((l1)[@env1 ]) ((q2)[@env2 ])) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env2": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env3": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb = 6 :: (((merge)[@env2 ]) [8] ((q2)[@env1 ])) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb = 6 :: (((merge)[@env1 ]) [8] []) in ((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstFun" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb = 6 ::\n  (((fun l1 ->\n       fun l2 ->\n         match (l1, l2) with\n         | (p1::q1, p2::q2) ->\n             if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n         | (_, []) -> l1\n         | ([], _) -> l2)[@env1 ]) [8] []) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb = 6 ::\n  ((fun l1 ->\n      ((fun l2 ->\n          match (l1, l2) with\n          | (p1::q1, p2::q2) ->\n              if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n          | (_, []) -> l1\n          | ([], _) -> l2)\n      [@env1 ])) [8] []) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb = 6 ::\n  ((fun l1 ->\n      fun l2 ->\n        ((match (l1, l2) with\n          | (p1::q1, p2::q2) ->\n              if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n          | (_, []) -> l1\n          | ([], _) -> l2)\n        [@env1 ])) [8] []) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb = 6 ::\n  ((fun l1 ->\n      fun l2 ->\n        match (l1, l2) with\n        | (p1::q1, p2::q2) ->\n            ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n            [@env1 ])\n        | (_, []) -> l1\n        | ([], _) -> l2) [8] []) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "ApplyFunComplete" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb = 6 ::\n  ((match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n        [@env1 ])\n    | (_, []) -> l1\n    | ([], _) -> l2)\n  [@env2 ]) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb = 6 ::\n  (match (((l1, l2))[@env5 ]) with\n   | (p1::q1, p2::q2) ->\n       ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n       [@env2 ][@env1 ])\n   | (_, []) -> ((l1)[@env3 ])\n   | ([], _) -> ((l2)[@env4 ])) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env3": {
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env4": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env5": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb = 6 ::\n  (match (((l1)[@env5 ]), ((l2)[@env6 ])) with\n   | (p1::q1, p2::q2) ->\n       ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n       [@env2 ][@env1 ])\n   | (_, []) -> ((l1)[@env3 ])\n   | ([], _) -> ((l2)[@env4 ])) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env3": {
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env4": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env5": {
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env6": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb = 6 ::\n  (match ([8], ((l2)[@env5 ])) with\n   | (p1::q1, p2::q2) ->\n       ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n       [@env2 ][@env1 ])\n   | (_, []) -> ((l1)[@env3 ])\n   | ([], _) -> ((l2)[@env4 ])) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env3": {
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env4": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env5": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "let bb = 6 ::\n  (match ([8], []) with\n   | (p1::q1, p2::q2) ->\n       ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n       [@env2 ][@env1 ])\n   | (_, []) -> ((l1)[@env3 ])\n   | ([], _) -> ((l2)[@env4 ])) in\n((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env2": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env3": {
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env4": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "Match" ]
  },
  {
    "current_expression": {
      "expr": "let bb = 6 :: ((l1)[@env1 ]) in ((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "l1": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr": "let bb = [6; 8] in ((merge)[@env0 ]) [7; 9] bb",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "Let" ]
  },
  {
    "current_expression": {
      "expr": "((((merge)[@env0 ]) [7; 9] bb)[@env1 ])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "bb": { "corec": [], "expr": { "expr": "[6; 8]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr": "((merge)[@env1 ]) [7; 9] ((bb)[@env0 ])",
      "envs": {
        "env0": {
          "bb": { "corec": [], "expr": { "expr": "[6; 8]", "envs": {} } }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr": "((merge)[@env0 ]) [7; 9] [6; 8]",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstFun" ]
  },
  {
    "current_expression": {
      "expr":
        "((fun l1 ->\n    fun l2 ->\n      match (l1, l2) with\n      | (p1::q1, p2::q2) ->\n          if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n      | (_, []) -> l1\n      | ([], _) -> l2)[@env0 ]) [7; 9] [6; 8]",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "(fun l1 ->\n   ((fun l2 ->\n       match (l1, l2) with\n       | (p1::q1, p2::q2) ->\n           if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n       | (_, []) -> l1\n       | ([], _) -> l2)\n   [@env0 ])) [7; 9] [6; 8]",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "(fun l1 ->\n   fun l2 ->\n     ((match (l1, l2) with\n       | (p1::q1, p2::q2) ->\n           if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n       | (_, []) -> l1\n       | ([], _) -> l2)\n     [@env0 ])) [7; 9] [6; 8]",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "(fun l1 ->\n   fun l2 ->\n     match (l1, l2) with\n     | (p1::q1, p2::q2) ->\n         ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n         [@env0 ])\n     | (_, []) -> l1\n     | ([], _) -> l2) [7; 9] [6; 8]",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "ApplyFunComplete" ]
  },
  {
    "current_expression": {
      "expr":
        "((match (l1, l2) with\n  | (p1::q1, p2::q2) ->\n      ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n      [@env0 ])\n  | (_, []) -> l1\n  | ([], _) -> l2)\n[@env1 ])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "l2": { "corec": [], "expr": { "expr": "[6; 8]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "match (((l1, l2))[@env4 ]) with\n| (p1::q1, p2::q2) ->\n    ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n    [@env1 ][@env0 ])\n| (_, []) -> ((l1)[@env2 ])\n| ([], _) -> ((l2)[@env3 ])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "l2": { "corec": [], "expr": { "expr": "[6; 8]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env2": {
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env3": {
          "l2": { "corec": [], "expr": { "expr": "[6; 8]", "envs": {} } }
        },
        "env4": {
          "l2": { "corec": [], "expr": { "expr": "[6; 8]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "match (((l1)[@env4 ]), ((l2)[@env5 ])) with\n| (p1::q1, p2::q2) ->\n    ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n    [@env1 ][@env0 ])\n| (_, []) -> ((l1)[@env2 ])\n| ([], _) -> ((l2)[@env3 ])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "l2": { "corec": [], "expr": { "expr": "[6; 8]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env2": {
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env3": {
          "l2": { "corec": [], "expr": { "expr": "[6; 8]", "envs": {} } }
        },
        "env4": {
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env5": {
          "l2": { "corec": [], "expr": { "expr": "[6; 8]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "match ([7; 9], ((l2)[@env4 ])) with\n| (p1::q1, p2::q2) ->\n    ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n    [@env1 ][@env0 ])\n| (_, []) -> ((l1)[@env2 ])\n| ([], _) -> ((l2)[@env3 ])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "l2": { "corec": [], "expr": { "expr": "[6; 8]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env2": {
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env3": {
          "l2": { "corec": [], "expr": { "expr": "[6; 8]", "envs": {} } }
        },
        "env4": {
          "l2": { "corec": [], "expr": { "expr": "[6; 8]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "match ([7; 9], [6; 8]) with\n| (p1::q1, p2::q2) ->\n    ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n    [@env1 ][@env0 ])\n| (_, []) -> ((l1)[@env2 ])\n| ([], _) -> ((l2)[@env3 ])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "l2": { "corec": [], "expr": { "expr": "[6; 8]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env2": {
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env3": {
          "l2": { "corec": [], "expr": { "expr": "[6; 8]", "envs": {} } }
        }
      }
    },
    "step": [ "Match" ]
  },
  {
    "current_expression": {
      "expr":
        "((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n[@env2 ][@env1 ][@env0 ])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "l2": { "corec": [], "expr": { "expr": "[6; 8]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env2": {
          "q2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } },
          "q1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "6", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "7", "envs": {} } }
        }
      }
    },
    "step": [ "SubstCombine" ]
  },
  {
    "current_expression": {
      "expr":
        "((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n[@env1 ][@env0 ])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "q2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } },
          "q1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "6", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "7", "envs": {} } },
          "l2": { "corec": [], "expr": { "expr": "[6; 8]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstCombine" ]
  },
  {
    "current_expression": {
      "expr":
        "((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))[@env0 ])",
      "envs": {
        "env0": {
          "q2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } },
          "q1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "6", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "7", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[6; 8]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "if ((p1 < p2)[@env2 ])\nthen ((p1 :: (merge q1 l2))[@env1 ])\nelse ((p2 :: (merge l1 q2))[@env0 ])",
      "envs": {
        "env0": {
          "q2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "6", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env1": {
          "q1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "7", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[6; 8]", "envs": {} } }
        },
        "env2": {
          "p2": { "corec": [], "expr": { "expr": "6", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "7", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "if ((p1)[@env2 ]) < ((p2)[@env3 ])\nthen ((p1 :: (merge q1 l2))[@env1 ])\nelse ((p2 :: (merge l1 q2))[@env0 ])",
      "envs": {
        "env0": {
          "q2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "6", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env1": {
          "q1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "7", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[6; 8]", "envs": {} } }
        },
        "env2": {
          "p1": { "corec": [], "expr": { "expr": "7", "envs": {} } }
        },
        "env3": {
          "p2": { "corec": [], "expr": { "expr": "6", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "if 7 < ((p2)[@env2 ])\nthen ((p1 :: (merge q1 l2))[@env1 ])\nelse ((p2 :: (merge l1 q2))[@env0 ])",
      "envs": {
        "env0": {
          "q2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "6", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env1": {
          "q1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "7", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[6; 8]", "envs": {} } }
        },
        "env2": {
          "p2": { "corec": [], "expr": { "expr": "6", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "if 7 < 6\nthen ((p1 :: (merge q1 l2))[@env1 ])\nelse ((p2 :: (merge l1 q2))[@env0 ])",
      "envs": {
        "env0": {
          "q2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "6", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env1": {
          "q1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "7", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[6; 8]", "envs": {} } }
        }
      }
    },
    "step": [ "ApplyFunRuntime" ]
  },
  {
    "current_expression": {
      "expr":
        "if false\nthen ((p1 :: (merge q1 l2))[@env1 ])\nelse ((p2 :: (merge l1 q2))[@env0 ])",
      "envs": {
        "env0": {
          "q2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "6", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env1": {
          "q1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "7", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[6; 8]", "envs": {} } }
        }
      }
    },
    "step": [ "If" ]
  },
  {
    "current_expression": {
      "expr": "((p2 :: (merge l1 q2))[@env0 ])",
      "envs": {
        "env0": {
          "q2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "6", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr": "((p2 :: (merge l1 q2))[@env0 ])",
      "envs": {
        "env0": {
          "q2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "6", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr": "((p2)[@env0 ]) :: ((merge l1 q2)[@env1 ])",
      "envs": {
        "env0": {
          "p2": { "corec": [], "expr": { "expr": "6", "envs": {} } }
        },
        "env1": {
          "q2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "((p2)[@env0 ]) :: (((merge)[@env3 ]) ((l1)[@env1 ]) ((q2)[@env2 ]))",
      "envs": {
        "env0": {
          "p2": { "corec": [], "expr": { "expr": "6", "envs": {} } }
        },
        "env1": {
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env2": {
          "q2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env3": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr": "6 :: (((merge)[@env2 ]) ((l1)[@env0 ]) ((q2)[@env1 ]))",
      "envs": {
        "env0": {
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env1": {
          "q2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr": "6 :: (((merge)[@env1 ]) [7; 9] ((q2)[@env0 ]))",
      "envs": {
        "env0": {
          "q2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr": "6 :: (((merge)[@env0 ]) [7; 9] [8])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstFun" ]
  },
  {
    "current_expression": {
      "expr":
        "6 ::\n(((fun l1 ->\n     fun l2 ->\n       match (l1, l2) with\n       | (p1::q1, p2::q2) ->\n           if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n       | (_, []) -> l1\n       | ([], _) -> l2)[@env0 ]) [7; 9] [8])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "6 ::\n((fun l1 ->\n    ((fun l2 ->\n        match (l1, l2) with\n        | (p1::q1, p2::q2) ->\n            if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n        | (_, []) -> l1\n        | ([], _) -> l2)\n    [@env0 ])) [7; 9] [8])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "6 ::\n((fun l1 ->\n    fun l2 ->\n      ((match (l1, l2) with\n        | (p1::q1, p2::q2) ->\n            if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n        | (_, []) -> l1\n        | ([], _) -> l2)\n      [@env0 ])) [7; 9] [8])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "6 ::\n((fun l1 ->\n    fun l2 ->\n      match (l1, l2) with\n      | (p1::q1, p2::q2) ->\n          ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n          [@env0 ])\n      | (_, []) -> l1\n      | ([], _) -> l2) [7; 9] [8])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "ApplyFunComplete" ]
  },
  {
    "current_expression": {
      "expr":
        "6 ::\n((match (l1, l2) with\n  | (p1::q1, p2::q2) ->\n      ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n      [@env0 ])\n  | (_, []) -> l1\n  | ([], _) -> l2)\n[@env1 ])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "6 ::\n(match (((l1, l2))[@env4 ]) with\n | (p1::q1, p2::q2) ->\n     ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n     [@env1 ][@env0 ])\n | (_, []) -> ((l1)[@env2 ])\n | ([], _) -> ((l2)[@env3 ]))",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env2": {
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env3": {
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env4": {
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "6 ::\n(match (((l1)[@env4 ]), ((l2)[@env5 ])) with\n | (p1::q1, p2::q2) ->\n     ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n     [@env1 ][@env0 ])\n | (_, []) -> ((l1)[@env2 ])\n | ([], _) -> ((l2)[@env3 ]))",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env2": {
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env3": {
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env4": {
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env5": {
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "6 ::\n(match ([7; 9], ((l2)[@env4 ])) with\n | (p1::q1, p2::q2) ->\n     ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n     [@env1 ][@env0 ])\n | (_, []) -> ((l1)[@env2 ])\n | ([], _) -> ((l2)[@env3 ]))",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env2": {
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env3": {
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env4": {
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "6 ::\n(match ([7; 9], [8]) with\n | (p1::q1, p2::q2) ->\n     ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n     [@env1 ][@env0 ])\n | (_, []) -> ((l1)[@env2 ])\n | ([], _) -> ((l2)[@env3 ]))",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env2": {
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env3": {
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "Match" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n[@env2 ][@env1 ][@env0 ])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env2": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "q1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "8", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "7", "envs": {} } }
        }
      }
    },
    "step": [ "SubstCombine" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n[@env1 ][@env0 ])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "q1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "8", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "7", "envs": {} } },
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstCombine" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))[@env0 ])",
      "envs": {
        "env0": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "q1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "8", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "7", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "6 ::\n(if ((p1 < p2)[@env2 ])\n then ((p1 :: (merge q1 l2))[@env1 ])\n else ((p2 :: (merge l1 q2))[@env0 ]))",
      "envs": {
        "env0": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "8", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env1": {
          "q1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "7", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env2": {
          "p2": { "corec": [], "expr": { "expr": "8", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "7", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "6 ::\n(if ((p1)[@env2 ]) < ((p2)[@env3 ])\n then ((p1 :: (merge q1 l2))[@env1 ])\n else ((p2 :: (merge l1 q2))[@env0 ]))",
      "envs": {
        "env0": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "8", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env1": {
          "q1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "7", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env2": {
          "p1": { "corec": [], "expr": { "expr": "7", "envs": {} } }
        },
        "env3": {
          "p2": { "corec": [], "expr": { "expr": "8", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "6 ::\n(if 7 < ((p2)[@env2 ])\n then ((p1 :: (merge q1 l2))[@env1 ])\n else ((p2 :: (merge l1 q2))[@env0 ]))",
      "envs": {
        "env0": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "8", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env1": {
          "q1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "7", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env2": {
          "p2": { "corec": [], "expr": { "expr": "8", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "6 ::\n(if 7 < 8\n then ((p1 :: (merge q1 l2))[@env1 ])\n else ((p2 :: (merge l1 q2))[@env0 ]))",
      "envs": {
        "env0": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "8", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env1": {
          "q1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "7", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "ApplyFunRuntime" ]
  },
  {
    "current_expression": {
      "expr":
        "6 ::\n(if true\n then ((p1 :: (merge q1 l2))[@env1 ])\n else ((p2 :: (merge l1 q2))[@env0 ]))",
      "envs": {
        "env0": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "8", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[7; 9]", "envs": {} } }
        },
        "env1": {
          "q1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "7", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "If" ]
  },
  {
    "current_expression": {
      "expr": "6 :: ((p1 :: (merge q1 l2))[@env0 ])",
      "envs": {
        "env0": {
          "q1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "7", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr": "6 :: ((p1 :: (merge q1 l2))[@env0 ])",
      "envs": {
        "env0": {
          "q1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "7", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr": "6 :: ((p1)[@env0 ]) :: ((merge q1 l2)[@env1 ])",
      "envs": {
        "env0": {
          "p1": { "corec": [], "expr": { "expr": "7", "envs": {} } }
        },
        "env1": {
          "q1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: ((p1)[@env0 ]) :: (((merge)[@env3 ]) ((q1)[@env1 ]) ((l2)[@env2 ]))",
      "envs": {
        "env0": {
          "p1": { "corec": [], "expr": { "expr": "7", "envs": {} } }
        },
        "env1": {
          "q1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env2": {
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env3": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr": "6 :: 7 :: (((merge)[@env2 ]) ((q1)[@env0 ]) ((l2)[@env1 ]))",
      "envs": {
        "env0": {
          "q1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env1": {
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr": "6 :: 7 :: (((merge)[@env1 ]) [9] ((l2)[@env0 ]))",
      "envs": {
        "env0": {
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr": "6 :: 7 :: (((merge)[@env0 ]) [9] [8])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstFun" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: 7 ::\n(((fun l1 ->\n     fun l2 ->\n       match (l1, l2) with\n       | (p1::q1, p2::q2) ->\n           if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n       | (_, []) -> l1\n       | ([], _) -> l2)[@env0 ]) [9] [8])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: 7 ::\n((fun l1 ->\n    ((fun l2 ->\n        match (l1, l2) with\n        | (p1::q1, p2::q2) ->\n            if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n        | (_, []) -> l1\n        | ([], _) -> l2)\n    [@env0 ])) [9] [8])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: 7 ::\n((fun l1 ->\n    fun l2 ->\n      ((match (l1, l2) with\n        | (p1::q1, p2::q2) ->\n            if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n        | (_, []) -> l1\n        | ([], _) -> l2)\n      [@env0 ])) [9] [8])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: 7 ::\n((fun l1 ->\n    fun l2 ->\n      match (l1, l2) with\n      | (p1::q1, p2::q2) ->\n          ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n          [@env0 ])\n      | (_, []) -> l1\n      | ([], _) -> l2) [9] [8])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "ApplyFunComplete" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: 7 ::\n((match (l1, l2) with\n  | (p1::q1, p2::q2) ->\n      ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n      [@env0 ])\n  | (_, []) -> l1\n  | ([], _) -> l2)\n[@env1 ])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: 7 ::\n(match (((l1, l2))[@env4 ]) with\n | (p1::q1, p2::q2) ->\n     ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n     [@env1 ][@env0 ])\n | (_, []) -> ((l1)[@env2 ])\n | ([], _) -> ((l2)[@env3 ]))",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env2": {
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env3": {
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env4": {
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: 7 ::\n(match (((l1)[@env4 ]), ((l2)[@env5 ])) with\n | (p1::q1, p2::q2) ->\n     ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n     [@env1 ][@env0 ])\n | (_, []) -> ((l1)[@env2 ])\n | ([], _) -> ((l2)[@env3 ]))",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env2": {
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env3": {
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env4": {
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env5": {
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: 7 ::\n(match ([9], ((l2)[@env4 ])) with\n | (p1::q1, p2::q2) ->\n     ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n     [@env1 ][@env0 ])\n | (_, []) -> ((l1)[@env2 ])\n | ([], _) -> ((l2)[@env3 ]))",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env2": {
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env3": {
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env4": {
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: 7 ::\n(match ([9], [8]) with\n | (p1::q1, p2::q2) ->\n     ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n     [@env1 ][@env0 ])\n | (_, []) -> ((l1)[@env2 ])\n | ([], _) -> ((l2)[@env3 ]))",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env2": {
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env3": {
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "Match" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: 7 :: ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n[@env2 ][@env1 ][@env0 ])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env2": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "q1": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "8", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "9", "envs": {} } }
        }
      }
    },
    "step": [ "SubstCombine" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: 7 :: ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n[@env1 ][@env0 ])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "q1": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "8", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "9", "envs": {} } },
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstCombine" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: 7 :: ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n[@env0 ])",
      "envs": {
        "env0": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "q1": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "8", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "9", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: 7 ::\n(if ((p1 < p2)[@env2 ])\n then ((p1 :: (merge q1 l2))[@env1 ])\n else ((p2 :: (merge l1 q2))[@env0 ]))",
      "envs": {
        "env0": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "8", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env1": {
          "q1": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "9", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env2": {
          "p2": { "corec": [], "expr": { "expr": "8", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "9", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: 7 ::\n(if ((p1)[@env2 ]) < ((p2)[@env3 ])\n then ((p1 :: (merge q1 l2))[@env1 ])\n else ((p2 :: (merge l1 q2))[@env0 ]))",
      "envs": {
        "env0": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "8", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env1": {
          "q1": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "9", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env2": {
          "p1": { "corec": [], "expr": { "expr": "9", "envs": {} } }
        },
        "env3": {
          "p2": { "corec": [], "expr": { "expr": "8", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: 7 ::\n(if 9 < ((p2)[@env2 ])\n then ((p1 :: (merge q1 l2))[@env1 ])\n else ((p2 :: (merge l1 q2))[@env0 ]))",
      "envs": {
        "env0": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "8", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env1": {
          "q1": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "9", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        },
        "env2": {
          "p2": { "corec": [], "expr": { "expr": "8", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: 7 ::\n(if 9 < 8\n then ((p1 :: (merge q1 l2))[@env1 ])\n else ((p2 :: (merge l1 q2))[@env0 ]))",
      "envs": {
        "env0": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "8", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env1": {
          "q1": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "9", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "ApplyFunRuntime" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: 7 ::\n(if false\n then ((p1 :: (merge q1 l2))[@env1 ])\n else ((p2 :: (merge l1 q2))[@env0 ]))",
      "envs": {
        "env0": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "8", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env1": {
          "q1": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p1": { "corec": [], "expr": { "expr": "9", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l2": { "corec": [], "expr": { "expr": "[8]", "envs": {} } }
        }
      }
    },
    "step": [ "If" ]
  },
  {
    "current_expression": {
      "expr": "6 :: 7 :: ((p2 :: (merge l1 q2))[@env0 ])",
      "envs": {
        "env0": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "8", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr": "6 :: 7 :: ((p2 :: (merge l1 q2))[@env0 ])",
      "envs": {
        "env0": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "p2": { "corec": [], "expr": { "expr": "8", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr": "6 :: 7 :: ((p2)[@env0 ]) :: ((merge l1 q2)[@env1 ])",
      "envs": {
        "env0": {
          "p2": { "corec": [], "expr": { "expr": "8", "envs": {} } }
        },
        "env1": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: 7 :: ((p2)[@env0 ]) :: (((merge)[@env3 ]) ((l1)[@env1 ]) ((q2)[@env2 ]))",
      "envs": {
        "env0": {
          "p2": { "corec": [], "expr": { "expr": "8", "envs": {} } }
        },
        "env1": {
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env2": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env3": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: 7 :: 8 :: (((merge)[@env2 ]) ((l1)[@env0 ]) ((q2)[@env1 ]))",
      "envs": {
        "env0": {
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env1": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env2": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr": "6 :: 7 :: 8 :: (((merge)[@env1 ]) [9] ((q2)[@env0 ]))",
      "envs": {
        "env0": {
          "q2": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env1": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr": "6 :: 7 :: 8 :: (((merge)[@env0 ]) [9] [])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "SubstFun" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: 7 :: 8 ::\n(((fun l1 ->\n     fun l2 ->\n       match (l1, l2) with\n       | (p1::q1, p2::q2) ->\n           if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n       | (_, []) -> l1\n       | ([], _) -> l2)[@env0 ]) [9] [])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: 7 :: 8 ::\n((fun l1 ->\n    ((fun l2 ->\n        match (l1, l2) with\n        | (p1::q1, p2::q2) ->\n            if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n        | (_, []) -> l1\n        | ([], _) -> l2)\n    [@env0 ])) [9] [])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: 7 :: 8 ::\n((fun l1 ->\n    fun l2 ->\n      ((match (l1, l2) with\n        | (p1::q1, p2::q2) ->\n            if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n        | (_, []) -> l1\n        | ([], _) -> l2)\n      [@env0 ])) [9] [])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: 7 :: 8 ::\n((fun l1 ->\n    fun l2 ->\n      match (l1, l2) with\n      | (p1::q1, p2::q2) ->\n          ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n          [@env0 ])\n      | (_, []) -> l1\n      | ([], _) -> l2) [9] [])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        }
      }
    },
    "step": [ "ApplyFunComplete" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: 7 :: 8 ::\n((match (l1, l2) with\n  | (p1::q1, p2::q2) ->\n      ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n      [@env0 ])\n  | (_, []) -> l1\n  | ([], _) -> l2)\n[@env1 ])",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: 7 :: 8 ::\n(match (((l1, l2))[@env4 ]) with\n | (p1::q1, p2::q2) ->\n     ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n     [@env1 ][@env0 ])\n | (_, []) -> ((l1)[@env2 ])\n | ([], _) -> ((l2)[@env3 ]))",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env2": {
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env3": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env4": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        }
      }
    },
    "step": [ "MoveDownSubst" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: 7 :: 8 ::\n(match (((l1)[@env4 ]), ((l2)[@env5 ])) with\n | (p1::q1, p2::q2) ->\n     ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n     [@env1 ][@env0 ])\n | (_, []) -> ((l1)[@env2 ])\n | ([], _) -> ((l2)[@env3 ]))",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env2": {
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env3": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env4": {
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env5": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: 7 :: 8 ::\n(match ([9], ((l2)[@env4 ])) with\n | (p1::q1, p2::q2) ->\n     ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n     [@env1 ][@env0 ])\n | (_, []) -> ((l1)[@env2 ])\n | ([], _) -> ((l2)[@env3 ]))",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env2": {
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env3": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        },
        "env4": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": {
      "expr":
        "6 :: 7 :: 8 ::\n(match ([9], []) with\n | (p1::q1, p2::q2) ->\n     ((if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2))\n     [@env1 ][@env0 ])\n | (_, []) -> ((l1)[@env2 ])\n | ([], _) -> ((l2)[@env3 ]))",
      "envs": {
        "env0": {
          "merge": {
            "corec": [ "merge" ],
            "expr": {
              "expr":
                "fun l1 ->\n  fun l2 ->\n    match (l1, l2) with\n    | (p1::q1, p2::q2) ->\n        if p1 < p2 then p1 :: (merge q1 l2) else p2 :: (merge l1 q2)\n    | (_, []) -> l1\n    | ([], _) -> l2",
              "envs": {}
            }
          }
        },
        "env1": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } },
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env2": {
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        },
        "env3": {
          "l2": { "corec": [], "expr": { "expr": "[]", "envs": {} } }
        }
      }
    },
    "step": [ "Match" ]
  },
  {
    "current_expression": {
      "expr": "6 :: 7 :: 8 :: ((l1)[@env0 ])",
      "envs": {
        "env0": {
          "l1": { "corec": [], "expr": { "expr": "[9]", "envs": {} } }
        }
      }
    },
    "step": [ "SubstVar" ]
  },
  {
    "current_expression": { "expr": "[6; 7; 8; 9]", "envs": {} },
    "step": []
  }
]